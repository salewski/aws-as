#!@BASH_SH@ -
# SPDX-FileCopyrightText: <text> Â© 2020 Alan D. Salewski <salewski@att.net> </text>
#
# SPDX-License-Identifier: GPL-2.0-or-later

# @configure_input@

# aws-as-activate.in: Emits a handful of shell functions and metadata
# variables that provide the 'aws-as' command (really a shell function) for
# the current shell. The user must 'eval' the output in order for the
# functionality to take effect in the current shell.
#
# Will augment the user's $PS1 shell variable to indicate the currently active
# AWS profile. The user's original PS1 variable definition is "remembered",
# and restored to its pristine state upon 'aws-as-deactivate' (see below).
#
# Usage:
#
#     $ eval "$(aws-as-activate -s)"
#
# CAREFUL: The double-quotes around the command are important in order to
#          avoid the shell emitting a syntax error.
#
#
# Once "installed" in the user's shell, all traces of the functionality can
# be removed by the installed 'aws-as-deactivate' function.

declare -r PROG='aws-as-activate.in'

declare -r COPYRIGHT_DATES='2020'

# declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'
declare -r MAINTAINER='@PACKAGE_BUGREPORT@'  # value filtered in at build time

declare -r VERSION='@VERSION@'  # value filtered in at build time

declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
#declare -r gl_const_release="${VERSION}"

# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

CAT_PROG="${CAT:-@CAT@}"
SED_PROG="${SED:-@SED@}"

BASH_PROG="${BASH:-@BASH_SH@}"
DATE_PROG="${DATE:-@DATE_PROG@}"
TRUE_PROG="${TRUE:-@TRUE_PROG@}"

CHMOD_PROG="${CHMOD:-@CHMOD_PROG@}"
MKDIR_PROG="${MKDIR:-@MKDIR_PROG@}"

#AWS_PROG="${AWS:-@AWS_PROG@}"
AWS_VAULT_PROG="${AWS_VAULT:-@AWS_VAULT_PROG@}"
#PYTHON3_PROG="${PYTHON:-@PYTHON@}"


opt_target_csh=false  # enable with -c  (or by a $SHELL that looks like a csh style shell)
opt_target_sh=false   # enable with -s  (or by a $SHELL that does not look like a csh style shell)


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $BE_VERBOSE; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

    cat <<EOF
usage: $PROG { -h | --help }
  or:  $PROG { -V | --version }
  or:  $PROG [OPTION...] { -c | --csh }
  or:  $PROG [OPTION...] { -s | --sh }

Generate aws-as command (and related) on stdout

WIP: Options with an asterisk (*) are placeholders for features not yet implemented

  -h, --help     Print this help message on stdout
  -V, --version  Print the version of the program on stdout
* -c, --csh      Generate C-shell commands on stdout. This is the default if
                   SHELL looks like it's a csh style of shell.
  -s, --sh       Generate Bourne shell commands on stdout. This is the default if
                   SHELL does not look like it's a csh style of shell.
  -v, --verbose  Print program progress messages on stderr. Specify multiple
                   times to increase verbosity: info, debug, and tracing (set -x)
      --         Signals the end of options and disables further options processing. Any
                   remaining arguments will cause an error to be emitted.

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['csh']=0       # -c
    ['sh']=0        # -s

    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hVcsv' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Note that we need to restore the leading '-' chars
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '--%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'csh' | 'c' )
                if $opt_target_sh; then
                    printf "${PROG} (error): opt -c (--csh) is mutually exclusive with -s (--sh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_csh=true

#FIXME: implement -c (--csh)
                printf "${PROG} (WIP): -c (--csh) feature not yet implemented; bailing out\n" 1>&2
                f_print_help 1>&2
                exit 1
                ;;


            'sh' | 's' )
                if $opt_target_csh; then
                    printf "${PROG} (error): opt -s (--sh) is mutually exclusive with -c (--csh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_sh=true
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level messages). Two -v
                # opts turns on $DEBUGGING, which additionally enables debug-level
                # messages. Three or more '-v' opts turns $TRACING on. Note that
                # if you intend to turn tracing on, you'll probably want your -v
                # opts to be the first opts on the command line (so they take
                # effect earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in 'xtrace'
                            # (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first thing
                            # that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;



            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; note that we need to restore the leading '-' that
                  # getopts has sliced off.
                  printf "${PROG} (error): unrecognized option '-%s'; bailing out\n" "${OPTARG}" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;

        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

if test $# -gt 0; then
    printf "${PROG} (error): unrecognized command line parameters (noted below); bailing out\n    %s\n" "$*" 1>&2
    exit 1
fi


if $opt_target_sh \
|| $opt_target_csh; then :; else

    # User did not specify either -s or -c option. We'll try to auto-detect
    # the user's shell from the $SHELL environment variable. If it looks like
    # a csh-style shell, then that's what we'll use. Otherwise we'll assume a
    # Bourne-style shell.
    #
    # Note: This approach of checking the last three characters of the name is
    #       borrowed from the ssh-agent(1), as shipped with OpenBSD's OpenSSH.
    #
    if test "${#SHELL}" -gt 2; then
        if [[ "${SHELL}" =~ .*csh$ ]]; then
            opt_target_csh=true
        fi
    fi
fi


if $opt_target_csh; then
    # csh-style shell

    printf "${PROG} (WIP): csh support not yet implemented; bailing out\n" 1>&2
    exit 1

    # FIXME: implement support for csh
else
    # Bourne-style shell

    # FIXME: For our initial version, we are assuming we can use bashisms

    # We'll populate this list of cleanup statements as we build up the
    # program, and then define a cleanup function with a static list of them
    # at the end of the generated program.
    #
    # Rationale: In the name of security, we want to avoid using 'eval' in the
    # cleanup function installed into the user's current shell environment. We
    # could define our variables as read-only, but then we would be forcing
    # the user to jump in and out of subshell when switch AWS profiles. OTOH,
    # if we use an in-process array of cleanup statements and do not make it
    # read-only, then there is no way to prevent malicious futzing with it
    # before we 'eval' the statements it contains.
    #
    # Instead, we can handle the registration of the static cleanup statements
    # here in the generating program, and then install a function with a
    # static definition of each of the cleanup statements in reverse
    # order. This is safer than using 'eval', and only slightly less
    # convenient here. We do still still get to keep most of the convenience
    # of registering the statements individually where the relevant code is
    # introduced.
    #
    # HINT: To create "spacer lines" in the generated cleanup function (to
    #       help keep the function readable, and also keep groups of related
    #       statements grouped together), use the ':' command.
    #
    declare -a t_cleanup_statements=()

    "${CAT_PROG}" - <<'EOF'

# If the user eval's the script twice, we do not want to create
# stacked-up prompt prefixes marching across our screen. Only set
# these upon our first time loading.
#
if test "${__t_v_aws_as_have_PS1_hold:+is_set}" = 'is_set'; then :; else

    __t_v_aws_as_PS1_hold=
    __t_v_aws_as_have_PS1_hold=false

    if test "${PS1:+is_set}" = 'is_set'; then

        __t_v_aws_as_PS1_hold=$PS1
        __t_v_aws_as_have_PS1_hold=true
    fi
fi
EOF

    t_cleanup_statements+=('unset -v __t_v_aws_as_PS1_hold')
    t_cleanup_statements+=('unset -v __t_v_aws_as_have_PS1_hold')
    t_cleanup_statements+=('${__t_v_aws_as_have_PS1_hold} && PS1=${__t_v_aws_as_PS1_hold}')

    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CAT_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_SED_PROG')
#    t_cleanup_statements+=('unset -v __T_V_AWS_AS_AWS_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_AWS_VAULT_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CHMOD_PROG')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_BASH_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_DATE_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_TRUE_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_MKDIR_PROG')
#    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PYTHON3_PROG')

    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__T_V_AWS_AS_CAT_PROG='${CAT_PROG}'
__T_V_AWS_AS_SED_PROG='${SED_PROG}'
#__T_V_AWS_AS_AWS_PROG='${AWS_PROG}'
__T_V_AWS_AS_AWS_VAULT_PROG='${AWS_VAULT_PROG}'
__T_V_AWS_AS_CHMOD_PROG='${CHMOD_PROG}'

__T_V_AWS_AS_BASH_PROG='${BASH_PROG}'
__T_V_AWS_AS_DATE_PROG='${DATE_PROG}'
__T_V_AWS_AS_TRUE_PROG='${TRUE_PROG}'
__T_V_AWS_AS_MKDIR_PROG='${MKDIR_PROG}'
#__T_V_AWS_AS_PYTHON3_PROG='${PYTHON3_PROG}'
EOF

    # switch back to using non-interpolated heredoc
    #
    t_cleanup_statements+=(':')

    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROFILE')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROFILE_NONE')
    t_cleanup_statements+=('unset -f __t_f_aws_as_maybe_update_PS1')
    "${CAT_PROG}" - <<'EOF'

__T_V_AWS_AS_PROFILE_NONE='_'

__T_V_AWS_AS_PROFILE=${__T_V_AWS_AS_PROFILE_NONE}
function __t_f_aws_as_maybe_update_PS1 () {
    if test "${PS1:+is_set}" = 'is_set'; then
        PS1='('"${__T_V_AWS_AS_PROFILE}"') '"${__t_v_aws_as_PS1_hold}"
    fi
}
__t_f_aws_as_maybe_update_PS1

# FIXME: In some scenarios, we might be able to use the "as is" active
#        profile (as indicated by the AWS_PROFILE env var). For now,
#        though, our basic implementation just clears out any AWS_*
#        env vars found in the environment that would conflict with our
#        usage. We are careful to keep track of them, though, and restore
#        the "as found" value to what they were originally when the user
#        invokes 'aws-as-deactivate'.
EOF

    # These will get hold values, and will then be unset in the current shell
    # during initialization.
    for vname in \
        'AWS_PROFILE' \
        'AWS_ACCESS_KEY_ID' \
        'AWS_SECRET_ACCESS_KEY' \
        'AWS_SESSION_TOKEN' \
        \
        'AWS_ROLE_SESSION_NAME'; do

        "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__t_v_aws_as_${vname}_hold=
__t_v_aws_as_have_${vname}_hold=false
if test "\${${vname}:+is_set}" = 'is_set'; then
    __t_v_aws_as_${vname}_hold=\$${vname}
    __t_v_aws_as_have_${vname}_hold=true
    unset ${vname}
fi
EOF
        # While 'aws-as' is active in the user's shell we may set and unset
        # the various AWS_* credential variables. To the extent possible, upon
        # deactivation we want to return the shell envinment to the state it
        # was in upon activation. That means unsetting the AWS_* vars if they
        # were not already set at the time of activation.

        t_cleanup_statements+=(':')
        t_cleanup_statements+=('unset -v __t_v_aws_as_'"${vname}"'_hold')
        t_cleanup_statements+=('unset -v __t_v_aws_as_have_'"${vname}"'_hold')
        t_cleanup_statements+=('${__t_v_aws_as_have_'"${vname}"'_hold} && '"${vname}"'=${__t_v_aws_as_'"${vname}"'_hold} || unset '"${vname}")
    done

    # Similar to the above, but these WILL NOT be unset in the current
    # shell. We want these to remain active "as found". We may overwrite their
    # values over time, but we remember their original values so we can
    # restore them upon deactivation, if needed.
    #
    for vname in \
        'aws_as_cfg_debug_init' \
        'aws_as_cfg_auto_hoist' ; do

        "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__t_v_aws_as_${vname}_hold=
__t_v_aws_as_have_${vname}_hold=false
if test "\${${vname}:+is_set}" = 'is_set'; then
    __t_v_aws_as_${vname}_hold=\$${vname}
    __t_v_aws_as_have_${vname}_hold=true
fi
EOF
        # To the extent possible, upon deactivation we want to return the
        # shell envinment to the state it was in upon activation. That means
        # unsetting the aws_as_cfg_* vars if they were not already set at the
        # time of activation, and restoring their original values if they were
        # set at the time of activation (i.e., they happened to be set on the
        # command line or were already present in the environment).

        t_cleanup_statements+=(':')
        t_cleanup_statements+=('unset -v __t_v_aws_as_'"${vname}"'_hold')
        t_cleanup_statements+=('unset -v __t_v_aws_as_have_'"${vname}"'_hold')
        t_cleanup_statements+=('${__t_v_aws_as_have_'"${vname}"'_hold} && '"${vname}"'=${__t_v_aws_as_'"${vname}"'_hold} || unset '"${vname}")
    done


    # FIXME: Maybe allow our .d directory to live someplace configurable. Some
    #        folks would likely prefer XDG-compliant behavior; consider adding
    #        it.
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_DOT_D_DIR')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CONFIG_FILE_NAME')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CONFIG_FILE_PATH')

    "${CAT_PROG}" - <<'EOF'

__T_V_AWS_AS_DOT_D_DIR="${HOME}/.aws-as.d"
if test -d "${__T_V_AWS_AS_DOT_D_DIR}"; then :; else
    "${__T_V_AWS_AS_MKDIR_PROG}" --mode '0700' "${__T_V_AWS_AS_DOT_D_DIR}"
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to create dir \"%s\"; stopping\n" \
               "${__T_V_AWS_AS_DOT_D_DIR}" 1>&2
        return 1
    fi
#    "${__T_V_AWS_AS_CHMOD_PROG}" 0700 "${__T_V_AWS_AS_DOT_D_DIR}"
#    if test $? -ne 0; then
#        printf "${__T_V_AWS_AS_PROG} (error): was unable to chmod dir \"%s\"; stopping\n" \
#               "${__T_V_AWS_AS_DOT_D_DIR}" 1>&2
#        return 1
#    fi
fi

# Default config file location: ~/.aws-as.d/init.sh
#
__T_V_AWS_AS_CONFIG_FILE_NAME='init.sh'
__T_V_AWS_AS_CONFIG_FILE_PATH="${__T_V_AWS_AS_DOT_D_DIR}/${__T_V_AWS_AS_CONFIG_FILE_NAME}"

EOF

    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f aws-as')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROG')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_BE_VERBOSE')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_DEBUGGING')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_TRACING')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CFG_DEBUG_INIT')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CFGINIT_DEBUG_INIT')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CFG_AUTO_HOIST')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CFGINIT_AUTO_HOIST')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f __t_f_aws_as_main')
    t_cleanup_statements+=('unset -f __t_f_aws_as_print_help')
    t_cleanup_statements+=('unset -f __t_f_aws_as_print_version')
    t_cleanup_statements+=('unset -f __t_f_aws_as_reset_dashv_flags')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f __t_f_aws_as_clear_env_of_creds')
    t_cleanup_statements+=('unset -f __t_f_aws_as_clear_cached_creds')
    t_cleanup_statements+=('unset -f __t_f_aws_as_unset_ineffect_profile')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f __t_f_aws_as_export_cred_vars')
    t_cleanup_statements+=('unset -f __t_f_aws_as_unexport_cred_vars')
    t_cleanup_statements+=('unset -f __t_f_aws_as_maybe_hoist_cred_vars')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f __t_f_aws_as_list_profiles')
    t_cleanup_statements+=('unset -f __t_f_aws_as_try_set_profile_as')

    # Design note: To the extent possible, the user-facing 'aws-as' function
    # should feel like a normal command to the end-user.
    #
    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__T_V_AWS_AS_PROG='aws-as'

__T_V_AWS_AS_BE_VERBOSE=false
__T_V_AWS_AS_DEBUGGING=false
__T_V_AWS_AS_TRACING=false

__T_V_AWS_AS_CFG_DEBUG_INIT=false
__T_V_AWS_AS_CFG_AUTO_HOIST=false

__t_f_aws_as_reset_dashv_flags () {
    __T_V_AWS_AS_BE_VERBOSE=false
    __T_V_AWS_AS_DEBUGGING=false
    __T_V_AWS_AS_TRACING=false
    return 0
}

__t_f_aws_as_print_help () {

    cat <<EODEF
usage: \$__T_V_AWS_AS_PROG [-v...] { -h | --help }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -V | --version }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -c | --clear-env }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -C | --clear-creds }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -E | --export }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -H | --hoist }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -L | --list-profiles }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -U | --unexport }
  or:  \$__T_V_AWS_AS_PROG [OPTION...] [--] AWS_CLI_PROFILE

Switch to using creds from the specified aws-cli profile,
authenticating with MFA, if necessary.

CAREFUL: Bundling of short-form options is not (yet?) supported.

  -h, --help           Print this help message on stdout
  -V, --version        Print the version of the program on stdout

  -c, --clear-env      Unset AWS_* credential variables in the current environment

  -C, --clear-creds    Clear cached temporary credentials from the aws-vault cache
                         for the in-effect aws-cli profile.
                         Implies -c (--clear-creds) and --none.

  -E, --export         Mark the AWS_* credential variables for export
                         Implies -H (--hoist).

  -U, --unexport       Un-mark the AWS_* creds vars for export (turn off 'x' attribute)
                         Implies -H (--hoist).

  -H, --hoist          "Hoist up" into the current environment AWS_* credential
                         variables associated with the in-effect profile

  -L, --list-profiles  Print list of aws-cli profiles on stdout

      --none           Unset the in-effect aws-cli profile
                         Alternatively, can be expressed as AWS_CLI_PROFILE '_'.

  -v, --verbose        Print program progress messages on stderr. Specify multiple
                         times to increase verbosity: info, debug, and tracing (set -x)

      --               Signals the end of options and disables further options processing.
                         Any remaining argument will be interpreted as teh AWS_CLI_PROFILE.

Report bugs to $MAINTAINER.
EODEF
}

__t_f_aws_as_print_version () {
    cat <<EODEF
\${__T_V_AWS_AS_PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EODEF
}
EOF


    # Note that aws-vault reads the profiles from ~/.aws/config, just like
    # 'aws configure list-profiles'. But aws-vault does it much faster.
    #
    # Note, too, that our error message indicates "aws-cli profiles", even
    # though it is the 'aws-vault' command being invoked; that is by design,
    # not a typo.
    #
    # See also:
    #     https://github.com/salewski/aws-as/issues/23
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_list_profiles () {

    local t_dopt=''
    if ${__T_V_AWS_AS_DEBUGGING}; then
        t_dopt='--debug'
    fi

    "${__T_V_AWS_AS_AWS_VAULT_PROG}" ${t_dopt} list --profiles
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was error while attempting to list the aws-cli profiles\n" 1>&2
        return 1
    fi

    return 0
}
EOF


    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_clear_env_of_creds () {

    local t_one_var_name
    for t_one_var_name in 'AWS_PROFILE' 'AWS_ACCESS_KEY_ID' 'AWS_SECRET_ACCESS_KEY' 'AWS_SESSION_TOKEN'; do

        if test "${!t_one_var_name:+is_set}" = 'is_set'; then

            if ${__T_V_AWS_AS_BE_VERBOSE}; then
                printf "${__T_V_AWS_AS_PROG} (info): unsetting env var: %s\n" "${t_one_var_name}" 1>&2
            fi
            unset "${t_one_var_name}"
        fi
    done

    return 0
}
EOF


    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_unset_ineffect_profile () {

    __t_f_aws_as_clear_env_of_creds
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was error while attempting to clear creds from env; will not unset in-effect profile\n" 1>&2
        return 1
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
       printf "${__T_V_AWS_AS_PROG} (debug): unsetting the in-effect profile\n" 1>&2
    fi

    __T_V_AWS_AS_PROFILE=${__T_V_AWS_AS_PROFILE_NONE}
    __t_f_aws_as_maybe_update_PS1
    return 0
}
EOF


    # Ensures both of the following:
    #
    #     1. AWS_* cred. vars are cleared from the current shell environment.
    #
    #     2. That aws-vault clears the temporary creds for the in-effect
    #        profile from its cache. If there is no in-effect profile, then
    #        only (1) is done.
    #
    # Since clearing the cached creds in aws-vault means the in-effect profile
    # will no longer be authenticated, this function implies an unsetting of
    # the in-effect profile, as well.
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_clear_cached_creds () {

    __t_f_aws_as_clear_env_of_creds
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was error while clearing AWS_* cred. vars from current env; stopping\n" 1>&2
        return 1
    fi

    if test "${__T_V_AWS_AS_PROFILE}" = "${__T_V_AWS_AS_PROFILE_NONE}"; then
        if ${__T_V_AWS_AS_BE_VERBOSE}; then
            printf "${__T_V_AWS_AS_PROG} (info): no in-effect profile; nothing to tell aws-vault to clear (okay)\n" 1>&2
        fi
        return 0
    fi

    if ${__T_V_AWS_AS_BE_VERBOSE}; then
        printf "${__T_V_AWS_AS_PROG} (info): requesting that aws-vault clear cached creds for profile: %s\n" \
            "${__T_V_AWS_AS_PROFILE}" 1>&2
    fi

    local -a t_global_opts=()

    if ${__T_V_AWS_AS_DEBUGGING}; then
        t_global_opts+='--debug'
    fi

    "${__T_V_AWS_AS_AWS_VAULT_PROG}" "${t_global_opts[@]}" clear "${__T_V_AWS_AS_PROFILE}"
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was error from aws-vault while clearing cached creds for profile: %s\n" \
            "${__T_V_AWS_AS_PROFILE}" 1>&2
        return 1
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): triggering unset of the in-effect profile\n" 1>&2
    fi

    __t_f_aws_as_unset_ineffect_profile

    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was error while unsetting the in-effect profile\n" 1>&2
        return 1
    fi

    return 0
}
EOF


    # Support for aws-as '-H' (--hoist) opt
    # https://github.com/salewski/aws-as/issues/26
    #
    # If there is no in-effect profile, then __t_f_aws_as_maybe_hoist_cred_vars()
    # is effectively a NOOP.
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_maybe_hoist_cred_vars () {

    if test "${__T_V_AWS_AS_PROFILE}" = "${__T_V_AWS_AS_PROFILE_NONE}"; then
        if ${__T_V_AWS_AS_BE_VERBOSE}; then
            printf "${__T_V_AWS_AS_PROG} (info): no in-effect profile; nothing to tell aws-vault to hoist (okay)\n" 1>&2
        fi
        return 0
    fi

    local -a t_global_opts=()

    if ${__T_V_AWS_AS_DEBUGGING}; then
        t_global_opts+='--debug'
    fi

    local t_subshell_script
    local t_response_script
    local t_vname

    t_subshell_script=': '$'\n'
    if ${__T_V_AWS_AS_TRACING}; then
        t_subshell_script="${t_subshell_script}"'set -x;'$'\n'
    fi

    # The resonse script will be evaled in the context of this function, so
    # the generated 'declare -- FOO' statements are switch to 'declare -g FOO'
    # so they will have the intended effect.
    #
    local t_check=''  # snippet 1
    local t_noexp=''  # snippet 2
    local t_declp=''  # snippet 3
    local t_clean=''  # snippet 4

    local t_combn=''  # above snippets, combined

    for t_vname in 'AWS_PROFILE' 'AWS_ACCESS_KEY_ID' 'AWS_SECRET_ACCESS_KEY' 'AWS_SESSION_TOKEN'; do

        t_check='test "${'"${t_vname}"'+is_set}" = "is_set" \'$'\n'

        t_noexp='&& declare +x '"${t_vname}"' \'$'\n'

        t_declp='&& declare -p '"${t_vname}"' \'$'\n'

        # The resonse script will be eval'd in the context of this function, so the
        # generated 'declare -- FOO' statements are switched to 'declare -g FOO'
        # so they will have the intended effect of setting the global variable of
        # the given name (rather than a local shell variable).
        #
        # We also ensure each line emitted ends with a semicolon.
        #
        t_clean='   | '"${__T_V_AWS_AS_SED_PROG}"' -e "s#^\(declare[[:space:]]\{1,\}\)--\([[:space:]]\{1,\}.*\)#\1-g\2#" -e "s#\$#\;#";'$'\n'

        t_combn="${t_check}${t_noexp}${t_declp}${t_clean}"

        t_subshell_script="${t_subshell_script}${t_combn}"
    done

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): generated subshell script for hoisting:\n---->8----\n%s\n----8<----\n" \
            "${t_subshell_script}" 1>&2
    fi

    t_response_script=$("${__T_V_AWS_AS_AWS_VAULT_PROG}" "${t_global_opts[@]}" \
                                                    exec "${__T_V_AWS_AS_PROFILE}" \
                                                         -- "${__T_V_AWS_AS_BASH_PROG}" -c "${t_subshell_script}")
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was error from aws-vault while generating env vars script for profile: %s\n" \
            "${__T_V_AWS_AS_PROFILE}" 1>&2
        return 1
    fi

    if test -z "${t_response_script}"; then
        printf "${__T_V_AWS_AS_PROG} (error): generated env vars script is empty; unable to hoist 'AWS_*' credential vars settings into the current environment; stopping\n" 1>&2
        return 1
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): generated response script for hoisting:\n---->8----\n%s\n----8<----\n" \
            "${t_response_script}" 1>&2
    fi

    # The generated script constructed from the bash-generated output of
    # 'declare -p' statements is safe to eval here.
    #
    eval "${t_response_script}"

    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): hoisting failed: was error while evaluating the AWS_* cred. env var settings from subprocess\n" 1>&2
        return 1
    fi

    return 0
}
EOF


    # Support for aws-as '-E' (--export) opt
    # https://github.com/salewski/aws-as/issues/3
    #
    # Note that it is possible for only a subset of the above set of vars to
    # be set (e.g., if the user set them manually), but by design we will only
    # export them if we are dealing with a complete set.
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_export_cred_vars () {

    __t_f_aws_as_maybe_hoist_cred_vars || return $?

    local t_cnt=0

    test -n "${AWS_ACCESS_KEY_ID}"     && (( ++t_cnt ))
    test -n "${AWS_SECRET_ACCESS_KEY}" && (( ++t_cnt ))
    test -n "${AWS_SESSION_TOKEN}"     && (( ++t_cnt ))

    if test $t_cnt -eq 3; then
        ${__T_V_AWS_AS_BE_VERBOSE} \
            && printf "${__T_V_AWS_AS_PROG} (info): exporting AWS_ACCESS_KEY_ID\n" 1>&2
        export AWS_ACCESS_KEY_ID

        ${__T_V_AWS_AS_BE_VERBOSE} \
            && printf "${__T_V_AWS_AS_PROG} (info): exporting AWS_SECRET_ACCESS_KEY\n" 1>&2
        export AWS_SECRET_ACCESS_KEY

        ${__T_V_AWS_AS_BE_VERBOSE} \
            && printf "${__T_V_AWS_AS_PROG} (info): exporting AWS_SESSION_TOKEN\n" 1>&2
        export AWS_SESSION_TOKEN

        return 0
    fi

    if test $t_cnt -gt 0; then
        printf "${__T_V_AWS_AS_PROG} (error): a partial set of 'AWS_*' cred vars are set in the env (manually set?); no new exports performed\n" 1>&2
    else
        printf "${__T_V_AWS_AS_PROG} (error): no aws creds are currently in effect, so no 'AWS_*' vars are set and available for export\n" 1>&2
    fi
    return 1
}
EOF


    # Support for aws-as '-U' (--unexport) opt
    # https://github.com/salewski/aws-as/issues/3
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_unexport_cred_vars () {

    __t_f_aws_as_maybe_hoist_cred_vars || return $?

    if test -n "${AWS_ACCESS_KEY_ID}"; then
        ${__T_V_AWS_AS_DEBUGGING} \
            && printf "${__T_V_AWS_AS_PROG} (debug): unexporting AWS_ACCESS_KEY_ID\n" 1>&2

        export -n AWS_ACCESS_KEY_ID
    fi

    if test -n "${AWS_SECRET_ACCESS_KEY}"; then
        ${__T_V_AWS_AS_DEBUGGING} \
            && printf "${__T_V_AWS_AS_PROG} (debug): unexporting AWS_SECRET_ACCESS_KEY\n" 1>&2

        export -n AWS_SECRET_ACCESS_KEY
    fi

    if test -n "${AWS_SESSION_TOKEN}"; then
        ${__T_V_AWS_AS_DEBUGGING} \
            && printf "${__T_V_AWS_AS_PROG} (debug): unexporting AWS_SESSION_TOKEN\n" 1>&2

        export -n AWS_SESSION_TOKEN
    fi

    return 0
}
EOF


    "${CAT_PROG}" - <<'EOF'

# @param: PROFILE
function __t_f_aws_as_try_set_profile_as () {

    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${__T_V_AWS_AS_PROG} (BUG): ${FUNCNAME}() invoked with %d args; %d required\n" \
            $# ${__required_count} 1>&2
        return 1
    fi

    local t_profile_name

    t_profile_name=$1

    if test -z "${t_profile_name}"; then
        printf "${__T_V_AWS_AS_PROG} (error): profile name may not be the empty string\n" 1>&2
        return 1
    fi

    # XXX: Technically, there might be a way to use a blank profile name
    #      in 'aws-cli', but for now we are not allowing it. Please let
    #      reach out if this causes you grief for some reason.
    #
    if [[ "${t_profile_name}" =~ ^[[:space:]]*$ ]]; then
        printf "${__T_V_AWS_AS_PROG} (error): profile name may not be blank\n" 1>&2
        return 1
    fi

    # A need may arise for us to allow a force-override of this behavior, but
    # for now we will just short-circuit (return early) since it looks like
    # there is no work to be done.
    #
    if test "${t_profile_name}" = "${__T_V_AWS_AS_PROFILE}"; then
        if ${__T_V_AWS_AS_BE_VERBOSE}; then
            printf "${__T_V_AWS_AS_PROG} (info): requested profile name is the same as the current profile; nothing to do\n" 1>&2
        fi
        return 0
    fi

    if test "${t_profile_name}" = "${__T_V_AWS_AS_PROFILE_NONE}"; then

        # User-specified magic short-hand syntax '_' for the profile name,
        # equivalent to our '--none' option.

        __t_f_aws_as_unset_ineffect_profile
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to reset the in-effect profile\n" 1>&2
            return 1
        fi
        return 0
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): querying aws-cli for current list of profiles\n" 1>&2
    fi

    local -a t_all_legit=()
    local t_dopt=''
    if ${__T_V_AWS_AS_DEBUGGING}; then
        t_dopt='--debug'
    fi
    for t_one_pname in $("${__T_V_AWS_AS_AWS_VAULT_PROG}" ${t_dopt} list --profiles); do
        t_all_legit+=("${t_one_pname}")
    done
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to obtain list of all legit aws-cli profile names\n" 1>&2
        return 1
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): aws-vault provided list of %d profiles\n" "${#t_all_legit[@]}" 1>&2
    fi

    local t_is_legit=false
    for t_one_pname in "${t_all_legit[@]}"; do
        if test "${t_one_pname}" = "${t_profile_name}"; then
            t_is_legit=true
            break
        fi
    done

    if $t_is_legit; then :; else
        {
            printf "${__T_V_AWS_AS_PROG} (error): \"%s\" is not a recognized aws-cli profile name\n" \
                   "${t_profile_name}"
            printf '    Legit profile names include:\n'
            for t_one_legit in "${t_all_legit[@]}"; do
                printf '        %s\n' "${t_one_legit}"
            done
        } 1>&2
        return 1
    fi

    # Give ourselves a "clean slate", as it were. This also helps avoid
    # unintended interactions between our aws-cli command line params
    # and any AWS_* variables that were set in the environment.
    #
    __t_f_aws_as_unset_ineffect_profile

    # This invocation of 'aws-vault' is being performed for the side-effect of
    # forcing the establishment, if necessary, of a session using temporary
    # STS credentials for the specified profile.
    #
    # If there is an existing aws-vault "session" (there is a set of cached
    # credentials), then the cached credentials will be re-used; no network
    # call to the AWS API will be made.
    #
    # If there is not an existing "session", then aws-vault will start one by
    # obtaining temporary creds appropriate for the specified aws-cli profile
    # (sts:GetSessionToken or sts:AssumeRole). If the profile has the
    # 'mfa_serial' config key present, then MFA will be used; this works for
    # both User and Role profiles (aws-vault honors the 'mfa_serial' key in
    # all profiles, even if 'aws-cli' only honors it for Role profiles).
    #
    local -a t_aws_vault_global_opts=()
    local -a t_aws_vault_subcmd_opts=()

    if ${__T_V_AWS_AS_DEBUGGING}; then
        t_aws_vault_global_opts+=('--debug')
    fi

    t_aws_vault_subcmd_opts+=("${t_profile_name}")
    t_aws_vault_subcmd_opts+=('--')
    t_aws_vault_subcmd_opts+=("${__T_V_AWS_AS_TRUE_PROG}")
    
    "${__T_V_AWS_AS_AWS_VAULT_PROG}" "${t_aws_vault_global_opts[@]}" \
                                exec "${t_aws_vault_subcmd_opts[@]}"
    if test $? -ne 0; then
        # Presumably a more specific error message was already emitted
        printf "${__T_V_AWS_AS_PROG} (error): was unable to establish or confirm aws-vault session for profile\n" 1>&2
        return 1
    fi

    # Finally, establish our new "switched to" profile settings
    #
    __T_V_AWS_AS_PROFILE=${t_profile_name}
    __t_f_aws_as_maybe_update_PS1


    if ${__T_V_AWS_AS_CFG_AUTO_HOIST}; then
        if ${__T_V_AWS_AS_BE_VERBOSE}; then
            printf "${__T_V_AWS_AS_PROG} (info): auto-hoisting is enabled; will hoist AWS_* cred. vars for profile\n" 1>&2
        fi
        __t_f_aws_as_maybe_hoist_cred_vars || return 1
    fi

    return 0
}
EOF


    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_main () {

    local t_profile_name
    local t_profile_name_provided=false

    while test $# -gt 0; do
        case $1 in
            '--help' | '-h')
                __t_f_aws_as_print_help
                return 0
                ;;

            '--version' | '-V')
                __t_f_aws_as_print_version
                return 0
                ;;


            '--clear-env' | '-c')
                __t_f_aws_as_clear_env_of_creds
                return $?
                ;;

            '--clear-creds' | '-C')
                __t_f_aws_as_clear_cached_creds
                return $?
                ;;


            '--export' | '-E')
                __t_f_aws_as_export_cred_vars
                return $?  # may be non-zero
                ;;

            '--unexport' | '-U')
                __t_f_aws_as_unexport_cred_vars
                return $?
                ;;

            '--hoist' | '-H')
                __t_f_aws_as_maybe_hoist_cred_vars
                return $?
                ;;


            '--list-profiles' | '-L')
                __t_f_aws_as_list_profiles
                return $?
                ;;


            '--none')
                __t_f_aws_as_unset_ineffect_profile
                if test $? -ne 0; then
                    printf "${__T_V_AWS_AS_PROG} (error): was unable to reset the in-effect profile\n" 1>&2
                    return 1
                fi
                return 0
                ;;


            '--verbose' | '-v' )
                if ${__T_V_AWS_AS_BE_VERBOSE}; then

                    if ${__T_V_AWS_AS_DEBUGGING}; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if ${__T_V_AWS_AS_TRACING}; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # Enable tracking before setting our app-level
                            # ${__T_V_AWS_AS_TRACING} flag so that setting it
                            # is the first thing that appears in the trace.
                            set -x
                            __T_V_AWS_AS_TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        __T_V_AWS_AS_DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${__T_V_AWS_AS_PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    __T_V_AWS_AS_BE_VERBOSE=true
                fi
                shift
                ;;


            '--')
                shift
                break
                ;;

            *)
                if [[ "$1" =~ ^[-].* ]]; then
                    printf "${__T_V_AWS_AS_PROG} (error): unrecognized option \"%s\"; bailing out\n" "${1}" 1>&2
                    __t_f_aws_as_print_help 1>&2
                    return 1
                fi
                if ${t_profile_name_provided}; then
                    printf "${__T_V_AWS_AS_PROG} (error): too many AWS_CLI_PROFILE parameters provided (\"%s\"); bailing out\n" "${1}" 1>&2
                    __t_f_aws_as_print_help 1>&2
                    return 1
                fi
                t_profile_name=$1
                t_profile_name_provided=true
                shift
                ;;
        esac
    done

    if ${t_profile_name_provided}; then
        if test $# -gt 1; then
            printf "${__T_V_AWS_AS_PROG} (error): have %d unrecognized parameters (%s); bailing out\n" "$#" "$@" 1>&2
            __t_f_aws_as_print_help 1>&2
            return 1
        fi
    else
        if test $# -gt 0; then
            t_profile_name=$1
            t_profile_name_provided=true
            shift
        elif test $# -lt 1; then
            printf "${__T_V_AWS_AS_PROG} (error): AWS_CLI_PROFILE parameter missing; bailing out\n" 1>&2
            __t_f_aws_as_print_help 1>&2
            return 1
        fi

        if test $# -gt 1; then
            printf "${__T_V_AWS_AS_PROG} (error): have %d unrecognized parameters (%s); bailing out\n" "$#" "$@" 1>&2
            __t_f_aws_as_print_help 1>&2
            return 1
        fi
    fi

    __t_f_aws_as_try_set_profile_as "${t_profile_name}"
    if test $? -ne 0; then
#        printf "${__T_V_AWS_AS_PROG} (error): error encountered while trying to switch to profile: \"%s\"; bailing out\n" "${t_profile_name}" 1>&2
        return 1
    fi

    return 0
}

function aws-as () {
    local t_rstat
    local t_xtrace_was_enabled=false
    case $- in
        *x*)
            t_xtrace_was_enabled=true
            ;;
        *)  # ignore
            ;;
    esac
    __t_f_aws_as_main "$@"
    t_rstat=$?

    __t_f_aws_as_reset_dashv_flags

    # If tracing was enabled during our run, we need to disable it again
    # (unless it had already been enabled to begin with)
    if [[ $- =~ .*x.* ]]; then
        if $t_xtrace_was_enabled; then
            : ${__T_V_AWS_AS_PROG} \(trace: $LINENO\): xtrace had previously been enabled -- no need to disable it
        else
            set +x
        fi
    fi

    return $t_rstat
}
EOF


    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_cleanup () {

    # Ignore any errors from the cleanup statements (what could we do
    # about them, anyway?), and keep going. It is better to potentially
    # leave one unintended artifact in the environment than "all the rest".

EOF
    let t_idx=${#t_cleanup_statements[@]}-1

    # Note that we're running the cleanup statements in opposite order from
    # which they were registered.
    #
    while test ${t_idx} -ge 0; do

        t_one_statement="${t_cleanup_statements[${t_idx}]}"

        if test -n "${t_one_statement}"; then
            "$CAT_PROG" - <<EOF  # Note: unlike the above, /these/ heredoc statements get interpolated
    ${t_one_statement}
EOF
        fi
        let t_idx=${t_idx}-1
    done
    "$CAT_PROG" - <<'EOF'

    # The very last statements in our cleanup function are the deletion
    # of the user-facing 'aws-as-deactivate' "command" (defined below)
    # and our cleanup function itself.
    #
    unset -f aws-as-deactivate
    unset -f __t_f_aws_as_cleanup
}

function aws-as-deactivate () {
    __t_f_aws_as_cleanup
}
EOF


    # Last initialization activity: "source" the user's ~/.aws-as.d/init.sh
    # file, creating the file first, if necessary.
    #
    "${CAT_PROG}" - <<'EOF'

if test -e "${__T_V_AWS_AS_CONFIG_FILE_PATH}"; then :; else

    > "${__T_V_AWS_AS_CONFIG_FILE_PATH}"
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to create aws-as config file: %s\n" \
            "${__T_V_AWS_AS_CONFIG_FILE_PATH}" 1>&2
    else
        "${__T_V_AWS_AS_CHMOD_PROG}" '0600' "${__T_V_AWS_AS_CONFIG_FILE_PATH}"
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to 'chmod 0600' aws-as config file: %s\n" \
                "${__T_V_AWS_AS_CONFIG_FILE_PATH}" 1>&2
        else

            "${__T_V_AWS_AS_CAT_PROG}" - <<EOINIT >> "${__T_V_AWS_AS_CONFIG_FILE_PATH}"
# -*- conf-unix -*-
#
# This is the customization file for aws-as(1), created automatically
# when the program was initialized on $(${__T_V_AWS_AS_DATE_PROG} -u -Iseconds)
#
# This file is a Bourne-style shell script snippet, and is "sourced" by the
# aws-as(1) program at initialization time. The default content lists all of
# the configuration variables available for the version of aws-as that
# produced the file, but newer versions may support additional config knobs
# not represented here.
#
# For the full list of valid aws-as config file variables that may appear
# here, see aws-as(1) or the project's online documentation:
#
#     https://salewski.github.io/aws-as/
#     https://github.com/salewski/aws-as
#
# HINT: The variables in this file can also be specified on the
#       aws-as-activate(1) command line that generates the aws-as(1) script
#       definition that is eval'd. Rather than:
#
#           \$ eval "\$(aws-as-activate -s)"
#
#       you can do something like this:
#
#           \$ eval "\$(printf '%s;\n' 'aws_as_cfg_debug_init=true' && aws-as-activate -s)"
#
#       or even this:
#
#           \$ eval "\$(printf '%s;\n' 'set -x' 'aws_as_cfg_debug_init=true' 'set +x' && aws-as-activate -s)"
#
# CAVEAT: Any variables set as described above will look to 'aws-as' to be
#         pre-existing in the environment, so will be restored to the
#         original setting as specified on the command line at deactivation
#         time; they will still be present in the environment after you
#         invoke aws-as-deactivate.

# Set to 'true' to cause aws-as initialization to emit debugging messages
# related to parsing this config file.
#
aws_as_cfg_debug_init=false

# When switching to a given aws-cli profile, AWS_* credential variables
# (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_SESSION_TOKEN) are
# not set in the current shell by default. If this setting is set to
# 'true', then the AWS_* cred. vars will be set (but but not exported)
# in the current environment.
#
aws_as_cfg_auto_hoist=false

EOINIT
        fi
    fi
fi

EOF

    # If the initialization falls through here, we should have a config file
    # to "source" (even if it is just an empty string).

    # Before sourcing the file, we first make note of any config file
    # variables that may have been set on the aws-as-activate command line (or
    # were already present in the environment). Those will take precedence
    # over the values sorced from the config file.
    #
    # This approach allows for the override mechanism noted in the hint
    # comment in our template config file above.

    # A config file variable is typically implemented by three related
    # variables in the script:
    #
    #     1. aws_as_cfg_FOO -- the name as it appears in the config file (and
    #                          possibly in the environment at initialization
    #                          time)
    #
    #     2. __T_V_AWS_CFGINIT_foo -- A "hold" variable to "remember" the
    #                          early initialization-time value, in case it
    #                          gets overwritten by the "sourced" config
    #                          file. The early initialization-time value will
    #                          take precedence.
    #
    #     3. __T_V_AWS_CFG_foo -- a boolean value set to indicate whether or
    #                          not the optional configurable behavior has been
    #                          enabled. This is the variable checked by the
    #                          main logic of the program to decide whether or
    #                          not to alter its behavior.

    "${CAT_PROG}" - <<'EOF'

__T_V_AWS_AS_CFGINIT_DEBUG_INIT=
__T_V_AWS_AS_CFGINIT_AUTO_HOIST=

# We treat the aws_as_cfg_debug_init setting specially, since enabling
# it earlier allows us to emit debugging messages about the rest.

if test "${aws_as_cfg_debug_init:+is_set}" = 'is_set'; then
    if [[ "${aws_as_cfg_debug_init}" =~ ^(true|false)$ ]]; then

        __T_V_AWS_AS_CFGINIT_DEBUG_INIT=${aws_as_cfg_debug_init}

        if ${__T_V_AWS_AS_CFGINIT_DEBUG_INIT}; then

            # Once set, this never flips back. The aws_as_cfg_debug_init value
            # (if any) sourced from the config file below will be effectively
            # ignored.
            #
            __T_V_AWS_AS_CFG_DEBUG_INIT=true
        fi

        if ${__T_V_AWS_AS_CFG_DEBUG_INIT}; then
            printf "${__T_V_AWS_AS_PROG} (debug): config key aws_as_cfg_debug_init: %s\n" \
                "${aws_as_cfg_debug_init}" 1>&2
        fi
    else
        printf "${__T_V_AWS_AS_PROG} (warn): ignoring bogus value found for config key aws_as_cfg_debug_init; should be 'true' or 'false'; got: \"%s\"\n" \
                "${aws_as_cfg_debug_init}" 1>&2
        # keep going...
    fi
fi


if test "${aws_as_cfg_auto_hoist:+is_set}" = 'is_set'; then
    __T_V_AWS_AS_CFGINIT_AUTO_HOIST=${aws_as_cfg_auto_hoist}
fi
EOF

    "${CAT_PROG}" - <<'EOF'

if test -e "${__T_V_AWS_AS_CONFIG_FILE_PATH}"; then

    # This may overwrite 'aws_as_cfg_*' vars seen in the env, even though
    # the config file has lower precedence than the env vars. That's okay,
    # though, because we captured the "initial" values above, and will restore
    # them below to re-establish proper precedence before attempting to use
    # them "for real".
    #
    source "${__T_V_AWS_AS_CONFIG_FILE_PATH}"
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): error encountered while trying to parse aws-as config file: %s\n" \
            "${__T_V_AWS_AS_CONFIG_FILE_PATH}" 1>&2
    fi
fi

# These 'aws_as_cfg_*' variables were probably "sourced" from the config file,
# but we'll use them whether they were or weren't because this allows the user
# to specify them on the command line to aws-as-activate(1), or similar, too.

if test "${aws_as_cfg_debug_init:+is_set}" = 'is_set'; then

    if test "${__T_V_AWS_AS_CFGINIT_DEBUG_INIT:+is_set}" = 'is_set'; then
        : nothing to do -- early cfginit debug handled above
    else
        if [[ "${aws_as_cfg_debug_init}" =~ ^(true|false)$ ]]; then

            if ${cfg_as_cfg_debug_init}; then
                __T_V_AWS_AS_CFG_DEBUG_INIT=true
            fi

            if ${__T_V_AWS_AS_CFG_DEBUG_INIT}; then
                printf "${__T_V_AWS_AS_PROG} (debug): config key aws_as_cfg_debug_init: %s\n" \
                    "${aws_as_cfg_debug_init}" 1>&2
            fi
        else
            printf "${__T_V_AWS_AS_PROG} (warn): ignoring bogus value found for config key aws_as_cfg_debug_init; should be 'true' or 'false'; got: \"%s\"\n" \
                    "${aws_as_cfg_debug_init}" 1>&2
            # keep going...
        fi
    fi
fi

if test "${aws_as_cfg_auto_hoist:+is_set}" = 'is_set'; then

    if test "${__T_V_AWS_AS_CFGINIT_AUTO_HOIST:+is_set}"; then
        # (maybe) restore env override of config file value
        aws_as_cfg_auto_hoist=${__T_V_AWS_AS_CFGINIT_AUTO_HOIST}
    fi

    if [[ "${aws_as_cfg_auto_hoist}" =~ ^(true|false)$ ]]; then

        if ${__T_V_AWS_AS_CFG_DEBUG_INIT}; then
            printf "${__T_V_AWS_AS_PROG} (debug): config key aws_as_cfg_auto_hoist: %s\n" \
                "${aws_as_cfg_auto_hoist}" 1>&2
        fi
        __T_V_AWS_AS_CFG_AUTO_HOIST=${aws_as_cfg_auto_hoist}
    else
        printf "${__T_V_AWS_AS_PROG} (warn): ignoring bogus value found for config key aws_as_cfg_auto_hoist; should be 'true' or 'false'; got: \"%s\"\n" \
                "${aws_as_cfg_auto_hoist}" 1>&2
        # keep going...
    fi
fi

EOF

fi


if $BE_VERBOSE; then
    printf "${PROG} (info): completed successfully\n" 1>&2
fi

exit 0;


#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball or RPM, for instance),
# you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='aws-as' \
#               --release='aws-as-0.1.0' \
#               --section='1' \
#               > /outputdir/aws-as-activate.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#
#     'man -l -'
#
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  aws-as-activate - Generate aws-as command (and related) on stdout


=head1 SYNOPSIS

  aws-as-activate --help
  aws-as-activate --version

  eval "$(aws-as-activate -s)"
  eval "$(aws-as-activate -c)"


=head1 DESCRIPTION

The C<aws-as-activate> program is part of the C<aws-as> project.

The C<aws-as-activate> program emits a handful of shell function definitions
and related metadata variables on stdout. These shell constructs provide the
L<aws-as(1)> command (really a shell function) for the current shell. The user
must C<eval> the output in order for the functionality to take effect in the
current shell. The output must be quoted in order to be fed to C<eval> as a
single chunk and to otherwise avoid the shell emitting a syntax error.

Once "installed" in the user's shell, all traces of the funcationality can be
removed by the installed L<aws-as-deactivate(1)> function.

The user's C<$PS1> shell prompt variable will be augmented to indicate the
currently active AWS profile. The original value for the varialbe is
"remembered", and restored to its pristine state upon invoking the
C<aws-as-deactivate> function.


=head1 OPTIONS

Below are the command line options currently accepted by C<aws-as-activate>.


=over 4

=item -h, --help

Print help usage message


=item -V, --version

Print the version of the program to stdout and then exit.


=item -c, --csh

B<WIP: This feature is not currently implemented>

Generate C-shell commands on stdout. This is the default if C<SHELL> looks
like it is a csh style of shell.

This option is mutually exclusive with C<-s> (C<--sh>); only one or the other
may be provided.


=item -s, --sh

B<WIP: This feature is not currently implemented>

Generate Bourne shell commands on stdout. This is the default if C<SHELL> does
not look like it is a csh style of shell.

This option is mutually exclusive with C<-c> (C<--csh>); only one or the other
may be provided.

B<CAREFUL:> This eary WIP version uses "bashisms"; pure POSIX shell support is planned


=item -v, --verbose

Turn on verbose mode. Causes program to emit messages on C<stderr> indicating
what it is doing. The option may be specified multiple times to increase
further the level of verbosity. One C<-v> option enables info-level output;
two such opts enable debug-level output; three or more enable trace-level
output.


=item --

Signals the end of options and disables further options processing.

=back


=head1 DIAGNOSTICS

Exits with zero on success, non-zero on error.


=head1 BUGS

There are probably tons. If you find any, please report them as described in
the C<BUGS> file.

HINT: L<https://github.com/salewski/aws-as/issues>


=head1 SEE ALSO

=over 4

=item aws-as(1)

=item aws-as-deactivate(1)

=back


=head1 AUTHOR

=over 4

=item Alan D. Salewski  <salewski@att.net>

=back


=head1 COPYRIGHT

Copyright 2020 Alan D. Salewski

=cut

