#!/bin/bash -
# SPDX-FileCopyrightText: <text> Â© 2020 Alan D. Salewski <salewski@att.net> </text>
#
# SPDX-License-Identifier: GPL-2.0-or-later

# aws-as-activate.in: Emits a handful of shell functions and metadata
# variables that provide the 'aws-as' command (really a shell function) for
# the current shell. The user must 'eval' the output in order for the
# functionality to take effect in the current shell.
#
# Will augment the user's $PS1 shell variable to indicate the currently active
# AWS profile. The user's original PS1 variable definition is "remembered",
# and restored to its pristine state upon 'aws-as-deactivate' (see below).
#
# Usage:
#
#     $ eval "$(aws-as-activate -s)"
#
# CAREFUL: The double-quotes around the command are important in order to
#          avoid the shell emitting a syntax error.
#
#
# Once "installed" in the user's shell, all traces of the funcationality can
# be removed by the installed 'aws-as-deactivate' function.

declare -r PROG='aws-as-activate.in'

declare -r COPYRIGHT_DATES='2020'

# declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'
declare -r MAINTAINER='@PACKAGE_BUGREPORT@'  # value filtered in at build time

declare -r VERSION='@VERSION@'  # value filtered in at build time

declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
#declare -r gl_const_release="${VERSION}"

# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

CAT_PROG="${CAT:-@CAT@}"
CHMOD_PROG="${CHMOD:-@CHMOD_PROG@}"
MKDIR_PROG="${MKDIR:-@MKDIR_PROG@}"
XARGS_PROG="${XARGS:-@XARGS_PROG@}"

AWS_PROG="${AWS:-@AWS_PROG@}"
JQ_PROG="${JQ:-@JQ_PROG@}"
PYTHON3_PROG="${PYTHON:-@PYTHON@}"


opt_target_csh=false  # enable with -c  (or by a $SHELL that looks like a csh style shell)
opt_target_sh=false   # enable with -s  (or by a $SHELL that does not look like a csh style shell)


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $BE_VERBOSE; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

    cat <<EOF
usage: $PROG { -h | --help }
  or:  $PROG { -V | --version }
  or:  $PROG [OPTION...] { -c | --csh }
  or:  $PROG [OPTION...] { -s | --sh }

Generate aws-as command (and related) on stdout

WIP: Options with an asterisk (*) are placeholders for features not yet implemented

  -h, --help     Print this help message on stdout
  -V, --version  Print the version of the program on stdout
* -c, --csh      Generate C-shell commands on stdout. This is the default if
                   SHELL looks like it's a csh style of shell.
  -s, --sh       Generate Bourne shell commands on stdout. This is the default if
                   SHELL does not look like it's a csh style of shell.
  -v, --verbose  Print program progress messages on stderr. Specify multiple
                   times to increase verbosity: info, debug, and tracing (set -x)
      --         Signals the end of options and disables further options processing. Any
                   remaining arguments will cause an error to be emitted.

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['csh']=0       # -c
    ['sh']=0        # -s

    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hVcsv' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Note that we need to restore the leading '-' chars
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '--%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'csh' | 'c' )
                if $opt_target_sh; then
                    printf "${PROG} (error): opt -c (--csh) is mutually exclusive with -s (--sh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_csh=true

#FIXME: implement -c (--csh)
                printf "${PROG} (WIP): -c (--csh) feature not yet implemented; bailing out\n" 1>&2
                f_print_help 1>&2
                exit 1
                ;;


            'sh' | 's' )
                if $opt_target_csh; then
                    printf "${PROG} (error): opt -s (--sh) is mutually exclusive with -c (--csh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_sh=true
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level messages). Two -v
                # opts turns on $DEBUGGING, which additionally enables debug-level
                # messages. Three or more '-v' opts turns $TRACING on. Note that
                # if you intend to turn tracing on, you'll probably want your -v
                # opts to be the first opts on the command line (so they take
                # effect earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in 'xtrace'
                            # (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first thing
                            # that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;



            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; note that we need to restore the leading '-' that
                  # getopts has sliced off.
                  printf "${PROG} (error): unrecognized option '-%s'; bailing out\n" "${OPTARG}" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;

        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

if test $# -gt 0; then
    printf "${PROG} (error): unrecognized command line parameters (noted below); bailing out\n    %s\n" "$*" 1>&2
    exit 1
fi


if $opt_target_sh \
|| $opt_target_csh; then :; else

    # User did not specify either -s or -c option. We'll try to auto-detect
    # the user's shell from the $SHELL environment variable. If it looks like
    # a csh-style shell, then that's what we'll use. Otherwise we'll assume a
    # Bourne-style shell.
    #
    # Note: This approach of checking the last three characters of the name is
    #       borrowed from the ssh-agent(1), as shipped with OpenBSD's OpenSSH.
    #
    if test "${#SHELL}" -gt 2; then
        if [[ "${SHELL}" =~ .*csh$ ]]; then
            opt_target_csh=true
        fi
    fi
fi


if $opt_target_csh; then
    # csh-style shell

    printf "${PROG} (WIP): csh support not yet implemented; bailing out\n" 1>&2
    exit 1

    # FIXME: implement support for csh
else
    # Bourne-style shell

    # FIXME: For our initial version, we are assuming we can use bashisms

    # We'll populate this list of cleanup statements as we build up the
    # program, and then define a cleanup function with a static list of them
    # at the end of the generated program.
    #
    # Rationale: In the name of security, we want to avoid using 'eval' in the
    # cleanup function installed into the user's current shell environment. We
    # could define our variables as read-only, but then we would be forcing
    # the user to jump in and out of subshell when switch AWS profiles. OTOH,
    # if we use an in-process array of cleanup statements and do not make it
    # read-only, then there is no way to prevent malicious futzing with it
    # before we 'eval' the statements it contains.
    #
    # Instead, we can handle the registration of the static cleanup statements
    # here in the generating program, and then install a function with a
    # static definition of each of the cleanup statements in reverse
    # order. This is safer than using 'eval', and only slightly less
    # convenient here. We do still still get to keep most of the convenience
    # of registering the statements individually where the relevant code is
    # introduced.
    #
    # HINT: To create "spacer lines" in the generated cleanup function (to
    #       help keep the function readable, and also keep groups of related
    #       statements grouped together), use the ':' command.
    #
    declare -a t_cleanup_statements=()

    "${CAT_PROG}" - <<'EOF'

# If the user eval's the script twice, we do not want to create
# stacked-up prompt prefixes marching across our screen. Only set
# these upon our first time loading.
#
if test "${__t_v_aws_as_have_PS1_hold:+is_set}" = 'is_set'; then :; else

    __t_v_aws_as_PS1_hold=
    __t_v_aws_as_have_PS1_hold=false

    if test "${PS1:+is_set}" = 'is_set'; then

        __t_v_aws_as_PS1_hold=$PS1
        __t_v_aws_as_have_PS1_hold=true
    fi
fi
EOF

    t_cleanup_statements+=('unset -v __t_v_aws_as_PS1_hold')
    t_cleanup_statements+=('unset -v __t_v_aws_as_have_PS1_hold')
    t_cleanup_statements+=('${__t_v_aws_as_have_PS1_hold} && PS1=${__t_v_aws_as_PS1_hold}')

    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_AWS_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CHMOD_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_MKDIR_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PYTHON3_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_JQ_PROG')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_XARGS_PROG')

    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__T_V_AWS_AS_AWS_PROG='${AWS_PROG}'
__T_V_AWS_AS_CHMOD_PROG='${CHMOD_PROG}'
__T_V_AWS_AS_MKDIR_PROG='${MKDIR_PROG}'
__T_V_AWS_AS_PYTHON3_PROG='${PYTHON3_PROG}'
__T_V_AWS_AS_JQ_PROG='${JQ_PROG}'
__T_V_AWS_AS_XARGS_PROG='${XARGS_PROG}'
EOF

    # switch back to using non-interpolated heredoc
    #
    t_cleanup_statements+=(':')

    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROFILE')
    t_cleanup_statements+=('unset -f __t_f_aws_as_maybe_update_PS1')
    "${CAT_PROG}" - <<'EOF'

__T_V_AWS_AS_PROFILE='-'
function __t_f_aws_as_maybe_update_PS1 () {
    if test "${PS1:+is_set}" = 'is_set'; then
        PS1='('"${__T_V_AWS_AS_PROFILE}"') '"${__t_v_aws_as_PS1_hold}"
    fi
}
__t_f_aws_as_maybe_update_PS1

# FIXME: In some scenarios, we might be able to use the "as is" active
#        profile (as indicated by the AWS_PROFILE env var). For now,
#        though, our basic implementation just clears out any AWS_*
#        env vars found in the environment that would conflict with our
#        usage. We are careful to keep track of them, though, and restore
#        the "as found" value to what they were originally when the user
#        invokes 'aws-as-deactivate'.
EOF

    for vname in \
        'AWS_PROFILE' \
        'AWS_ACCESS_KEY_ID' \
        'AWS_SECRET_ACCESS_KEY' \
        'AWS_SESSION_TOKEN' \
        \
        'AWS_ROLE_SESSION_NAME'; do

        "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__t_v_aws_as_${vname}_hold=
__t_v_aws_as_have_${vname}_hold=false
if test "\${${vname}:+is_set}" = 'is_set'; then
    __t_v_aws_as_${vname}_hold=\$${vname}
    __t_v_aws_as_have_${vname}_hold=true
    unset ${vname}
fi
EOF

        t_cleanup_statements+=(':')
        t_cleanup_statements+=('unset -v __t_v_aws_as_'"${vname}"'_hold')
        t_cleanup_statements+=('unset -v __t_v_aws_as_have_'"${vname}"'_hold')
        t_cleanup_statements+=('${__t_v_aws_as_have_'"${vname}"'_hold} && '"${vname}"'=${__t_v_aws_as_'"${vname}"'_hold}')
    done


    # FIXME: Maybe allow our .d directory to live someplace configurable. Some
    #        folks would likely prefer XDG-compliant behavior; consider adding
    #        it.
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_DOT_D_DIR')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_CACHE_DIR')
    "${CAT_PROG}" - <<'EOF'

__T_V_AWS_AS_DOT_D_DIR="${HOME}/.aws-as.d"
if test -d "${__T_V_AWS_AS_DOT_D_DIR}"; then :; else
    "${__T_V_AWS_AS_MKDIR_PROG}" --mode '0700' "${__T_V_AWS_AS_DOT_D_DIR}"
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to create dir \"%s\"; stopping\n" \
               "${__T_V_AWS_AS_DOT_D_DIR}" 1>&2
        return 1
    fi
#    "${__T_V_AWS_AS_CHMOD_PROG}" 0700 "${__T_V_AWS_AS_DOT_D_DIR}"
#    if test $? -ne 0; then
#        printf "${__T_V_AWS_AS_PROG} (error): was unable to chmod dir \"%s\"; stopping\n" \
#               "${__T_V_AWS_AS_DOT_D_DIR}" 1>&2
#        return 1
#    fi
fi
__T_V_AWS_AS_CACHE_DIR="${__T_V_AWS_AS_DOT_D_DIR}/cache"
if test -d "${__T_V_AWS_AS_CACHE_DIR}"; then :; else
    "${__T_V_AWS_AS_MKDIR_PROG}" --mode '0700' "${__T_V_AWS_AS_CACHE_DIR}"
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to create dir \"%s\"; stopping\n" \
               "${__T_V_AWS_AS_CACHE_DIR}" 1>&2
        return 1
    fi
#    "${__T_V_AWS_AS_CHMOD_PROG}" 0700 "${__T_V_AWS_AS_CACHE_DIR}"
#    if test $? -ne 0; then
#        printf "${__T_V_AWS_AS_PROG} (error): was unable to chmod dir \"%s\"; stopping\n" \
#               "${__T_V_AWS_AS_CACHE_DIR}" 1>&2
#        return 1
#    fi
fi
EOF

    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f aws-as')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROG')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_BE_VERBOSE')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_DEBUGGING')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_TRACING')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f __t_f_aws_as_main')
    t_cleanup_statements+=('unset -f __t_f_aws_as_print_help')
    t_cleanup_statements+=('unset -f __t_f_aws_as_print_version')
    t_cleanup_statements+=('unset -f __t_f_aws_as_reset_dashv_flags')
    t_cleanup_statements+=('unset -f __t_f_aws_as_clear_out_creds')
    t_cleanup_statements+=('unset -f __t_f_aws_as_export_cred_vars')
    t_cleanup_statements+=('unset -f __t_f_aws_as_unexport_cred_vars')
    t_cleanup_statements+=('unset -f __t_f_aws_as_try_set_profile_as')
    t_cleanup_statements+=('unset -f __t_f_aws_as_try_set_profile_as_for_user')
    t_cleanup_statements+=('unset -f __t_f_aws_as_try_set_profile_as_for_role')

    # Design note: To the extent possible, the user-facing 'aws-as' function
    # should feel like a normal command to the end-user.
    #
    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__T_V_AWS_AS_PROG='aws-as'

__T_V_AWS_AS_BE_VERBOSE=false
__T_V_AWS_AS_DEBUGGING=false
__T_V_AWS_AS_TRACING=false

__t_f_aws_as_reset_dashv_flags () {
    __T_V_AWS_AS_BE_VERBOSE=false
    __T_V_AWS_AS_DEBUGGING=false
    __T_V_AWS_AS_TRACING=false
    return 0
}

__t_f_aws_as_print_help () {

    cat <<EODEF
usage: \$__T_V_AWS_AS_PROG [-v...] { -h | --help }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -V | --version }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -C | --clear-creds }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -E | --export }
  or:  \$__T_V_AWS_AS_PROG [-v...] { -U | --unexport }
  or:  \$__T_V_AWS_AS_PROG [OPTION...] [--] AWS_CLI_PROFILE

Switch to specified profile, authenticating with MFA, if necessary.

CAREFUL: Bundling of short-form options is not (yet?) supported.

  -h, --help         Print this help message on stdout
  -V, --version      Print the version of the program on stdout

  -C, --clear-creds  Unset AWS_* credential variables in the environment
  -E, --export       Mark the AWS_* credential variables for export
  -U, --unexport     Un-mark the AWS_* creds vars for export (turn off 'x' attribute)

  -v, --verbose      Print program progress messages on stderr. Specify multiple
                       times to increase verbosity: info, debug, and tracing (set -x)

      --             Signals the end of options and disables further options processing.
                       Any remaining argument will be interpreted as teh AWS_CLI_PROFILE.

Report bugs to $MAINTAINER.
EODEF
}

__t_f_aws_as_print_version () {
    cat <<EODEF
\${__T_V_AWS_AS_PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EODEF
}
EOF

    # switch back to using non-interpolated heredoc
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_clear_out_creds () {

    unset AWS_PROFILE
    unset AWS_ACCESS_KEY_ID
    unset AWS_SECRET_ACCESS_KEY
    unset AWS_SESSION_TOKEN

    __T_V_AWS_AS_PROFILE='-'
    __t_f_aws_as_maybe_update_PS1
    return 0
}
EOF

    # Support for aws-as '-E' (--export) opt
    # https://github.com/salewski/aws-as/issues/3
    #
    # Note that it is possible for only a subset of the above set of vars to
    # be set (e.g., if the user set them manually), but by design we will only
    # export them if we are dealing with a complete set.
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_export_cred_vars () {

    local t_cnt=0

    test -n "${AWS_ACCESS_KEY_ID}"     && (( ++t_cnt ))
    test -n "${AWS_SECRET_ACCESS_KEY}" && (( ++t_cnt ))
    test -n "${AWS_SESSION_TOKEN}"     && (( ++t_cnt ))

    if test $t_cnt -eq 3; then
        ${__T_V_AWS_AS_BE_VERBOSE} \
            && printf "${__T_V_AWS_AS_PROG} (info): exporting AWS_ACCESS_KEY_ID\n" 1>&2
        export AWS_ACCESS_KEY_ID

        ${__T_V_AWS_AS_BE_VERBOSE} \
            && printf "${__T_V_AWS_AS_PROG} (info): exporting AWS_SECRET_ACCESS_KEY\n" 1>&2
        export AWS_SECRET_ACCESS_KEY

        ${__T_V_AWS_AS_BE_VERBOSE} \
            && printf "${__T_V_AWS_AS_PROG} (info): exporting AWS_SESSION_TOKEN\n" 1>&2
        export AWS_SESSION_TOKEN

        return 0
    fi

    if test $t_cnt -gt 0; then
        printf "${__T_V_AWS_AS_PROG} (error): a partial set of 'AWS_*' cred vars are set in the env (manually set?); no new exports performed\n" 1>&2
    else
        printf "${__T_V_AWS_AS_PROG} (error): no aws creds are currently in effect, so no 'AWS_*' vars are set and available for export\n" 1>&2
    fi
    return 1
}
EOF

    # Support for aws-as '-U' (--unexport) opt
    # https://github.com/salewski/aws-as/issues/3
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_unexport_cred_vars () {

    if test -n "${AWS_ACCESS_KEY_ID}"; then
        ${__T_V_AWS_AS_DEBUGGING} \
            && printf "${__T_V_AWS_AS_PROG} (debug): unexporting AWS_ACCESS_KEY_ID\n" 1>&2

        export -n AWS_ACCESS_KEY_ID
    fi

    if test -n "${AWS_SECRET_ACCESS_KEY}"; then
        ${__T_V_AWS_AS_DEBUGGING} \
            && printf "${__T_V_AWS_AS_PROG} (debug): unexporting AWS_SECRET_ACCESS_KEY\n" 1>&2

        export -n AWS_SECRET_ACCESS_KEY
    fi

    if test -n "${AWS_SESSION_TOKEN}"; then
        ${__T_V_AWS_AS_DEBUGGING} \
            && printf "${__T_V_AWS_AS_PROG} (debug): unexporting AWS_SESSION_TOKEN\n" 1>&2

        export -n AWS_SESSION_TOKEN
    fi

    return 0
}
EOF


    # For IAM Roles, we leverage the caching scheme implemented by aws-cli, so
    # do not cache that type of temporary credential (from sts:AssumeRole)
    # directly.

    # For IAM Users, we do implement our own cache (because aws-cli does not
    # provide one for that type of temporary credential (from
    # sts:GetSessionToken). Our caching scheme is modeled on that provided by
    # aws-cli for caching the Role creds, though, so if you understand one of
    # them you basically understand both of them.
    #
    # Our IAM User creds cache is based on:
    #
    #     User ARN: the 'Arn' key provided by sts:GetCallerIdentity when invoked by an IAM User.
    #
    #     MFA Device Serial Number (if available), as obtained from 'aws configure get' for the profoile.
    #
    # To avoid repeated calls to sts:GetCallerIdentity, we maintain a mapping
    # between aws-cli profile names and the User ARNs we've seen thus
    # far. This makes switching back to a given User profile faster for us.

    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROF_TO_UARN')  # "profile names to user-ARNs"
    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

declare -A __T_V_AWS_AS_PROF_TO_UARN
EOF

    "${CAT_PROG}" - <<'EOF'

# Helper for __t_f_aws_as_try_set_profile_as()
# @param: PROFILE (presumed validated)
#
function __t_f_aws_as_try_set_profile_as_for_user () {

    local t_profile_name
    local t_user_arn
    local t_mfa_serial

    t_profile_name=$1

    if test "${__T_V_AWS_AS_PROF_TO_UARN[${t_profile_name}]:+exists}"; then
        t_user_arn=${__T_V_AWS_AS_PROF_TO_UARN[${t_profile_name}]}
    else
        # We'll have to ask sts:GetCallerIdentity for it, but we'll cache
        # the answer for this profile so we do need to keep asking in the
        # future.
        #
        local t_rsp
        t_rsp=$("${__T_V_AWS_AS_AWS_PROG}" --profile "${t_profile_name}" --output 'text' \
                                       sts get-caller-identity \
                                           --query 'Arn')
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): get-caller-identity failed for profile '%s'; stopping\n" "${t_profile_name}" 1>&2
            return 1
        fi
        if test -z "${t_rsp}"; then
            printf "${__T_V_AWS_AS_PROG} (error): empty string output returned from get-caller-identity for profile '%s' (???); stopping\n" "${t_profile_name}" 1>&2
            return 1
        fi
        t_user_arn=$t_rsp
        unset t_rsp

        __T_V_AWS_AS_PROF_TO_UARN["${t_profile_name}"]=${t_user_arn}  # cache User ARN
    fi

    # CAREFUL: Using 'aws_as_' prefixed custom key here, since the aws-cli
    #          configuration does not directly support storing the MFA serial
    #          number for non-Role profiles. If a profile has an 'mfa_serial'
    #          key, then it is expected to have a 'role_arn' key, as well; you
    #          will get an error if you have an 'mfa_serial' key in the section
    #          for a non-Role profile.
    #
    #          However, the 'aws-cli configuration' subcommand is sufficiently
    #          general that it /will/ allow us to store (nearly) arbitrary
    #          key/value pairs in the file. We therefore claim the namespace
    #          prefix "aws_as_" for keys related to 'aws-as'.
    #
    t_mfa_serial=$("${__T_V_AWS_AS_AWS_PROG}" --profile "${t_profile_name}" configure get 'aws_as_mfa_serial')

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): t_user_arn is:   '%s'\n" "${t_user_arn}"   1>&2
        printf "${__T_V_AWS_AS_PROG} (debug): t_mfa_serial is: '%s'\n" "${t_mfa_serial}" 1>&2
    fi

    # This is similar to what aws-cli creates the hashcodes used for the
    # cached IAM Role creds.
    #
    # Note that the keys are alphabetically sorted; order here matters.
    #
    local t_cachefile_key=$("${__T_V_AWS_AS_PYTHON3_PROG}" -c '
import sys; import json; from hashlib import sha1;
arn = sys.argv[1];
sn  = sys.argv[2];
if len(sn) > 0:
    print( sha1( json.JSONEncoder().encode({"Arn": arn, "SerialNumber": sn}).encode("utf-8") ).hexdigest() )
else:
    print( sha1( json.JSONEncoder().encode({"Arn": arn}).encode("utf-8") ).hexdigest() )
                            ' \
                            "${t_user_arn}"   \
                            "${t_mfa_serial}" \
                           )
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to generate cache file key for user\n" 1>&2
        return 1
    fi
    if test -z "${t_cachefile_key}"; then
        printf "${__T_V_AWS_AS_PROG} (error): generated cache file key for user is empty(???)\n" 1>&2
        return 1
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): generated cache file key for user is '%s'\n" "${t_cachefile_key}" 1>&2
    fi

    local t_fpath="${__T_V_AWS_AS_CACHE_DIR}/${t_cachefile_key}.json"

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): cache filepath is '%s'\n" "${t_fpath}" 1>&2
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        if test -e "${t_fpath}"; then
            printf "${__T_V_AWS_AS_PROG} (debug): cache file exists: '%s'\n" "${t_fpath}" 1>&2
        else
            printf "${__T_V_AWS_AS_PROG} (debug): cache file does not (yet) exist: '%s'\n" "${t_fpath}" 1>&2
        fi
    fi

    local t_access_key_id
    local t_secret_access_key
    local t_session_token
    local t_expiration_utc

    if test -e "${t_fpath}"; then

        # read cached creds and expiration timestamp from file cache
        # (xargs is there to flatten multiple lines down into one)
        read -r t_access_key_id     \
                t_secret_access_key \
                t_session_token     \
                t_expiration_utc <  \
          <("${__T_V_AWS_AS_XARGS_PROG}" < <("${__T_V_AWS_AS_JQ_PROG}" --raw-output \
                '.Credentials | .AccessKeyId, .SecretAccessKey, .SessionToken, .Expiration' \
                < "${t_fpath}"))
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to parse user creds cache file: %s\n" \
                "${t_fpath}" 1>&2
            return 1
        fi
        if test -z "${t_access_key_id}"; then
            printf "${__T_V_AWS_AS_PROG} (error): parsed empty access key from user creds cache file: %s\n" \
                "${t_fpath}" 1>&2
            return 1
        fi
        if test -z "${t_secret_access_key}"; then
            printf "${__T_V_AWS_AS_PROG} (error): parsed empty secret access key from user creds cache file: %s\n" \
                "${t_fpath}" 1>&2
            return 1
        fi
        if test -z "${t_session_token}"; then
            printf "${__T_V_AWS_AS_PROG} (error): parsed empty session token from user creds cache file: %s\n" \
                "${t_fpath}" 1>&2
            return 1
        fi
        if test -z "${t_expiration_utc}"; then
            printf "${__T_V_AWS_AS_PROG} (error): parsed empty expiration timestamp from user creds cache file: %s\n" \
                "${t_fpath}" 1>&2
            return 1
        fi

    else

        # obtain temporary creds (sts:GetSessionToken) and cache them in file

        local t_mfa_token_code

        if test -n "${t_mfa_serial}"; then

            # The profile requires MFA authentication, we will handle
            # ourselves the prompting the user for the MFA token code.

            if test -t 0; then :; else
                printf "${__T_V_AWS_AS_PROG} (error): need to prompt user for MFA token, but stdin is not a terminal; stopping\n" 1>&2
                return 1
            fi

            # Prompt here is designed to look just like the one emitted by aws-cli:
            #
            #      Enter MFA code for <mfa-serial-number>:
            #
            # We'll wait 90 seconds for the user to enter the value before giving
            # up. That should be enough time that any futzing with the device can be
            # accommodated.
            #
            read -r -s -t 90 -p "Enter MFA code for ${t_mfa_serial}: " t_mfa_token_code
            if test $? -ne 0; then
                # If our read timed-out or was interrupted, we will not retry
                printf '\n'"${__T_V_AWS_AS_PROG} (error): was unable to obtain MFA code for device '%s'; stopping\n" \
                    "${t_mfa_serial}" 1>&2
                return 1
            fi
            printf '\n'  # advance the line, post-prompting

            # XXX: Writing in 2020-09, a valid MFA token is a six-digit code. We are
            #      hard-coding that here to optimize for the current common case, but
            #      we'll need to change this code in the future if the format changes
            #      (e.g., if AWS starts accepting more than six digits).
            #
            if [[ ${t_mfa_token_code} =~ ^[[:digit:]]{6}$ ]]; then :; else
                printf "${__T_V_AWS_AS_PROG} (error): invalid MFA code entered -- must be exactly six digits; stopping\n" 1>&2
                return 1
            fi
        fi

        local -a t_global_opts=()
        local -a t_srvice_opts=()
        local -a t_subcmd_opts=()

        t_global_opts+=('--profile')
        t_global_opts+=("${t_profile_name}")

        t_global_opts+=('--output')
#        t_global_opts+=('text')
        t_global_opts+=('json')

#        t_global_opts+=('--query')
#        t_global_opts+=('Credentials.[AccessKeyId,SecretAccessKey,SessionToken,Expiration]')

        if test -n "${t_mfa_serial}"; then
            t_subcmd_opts+=('--serial-number')
            t_subcmd_opts+=("${t_mfa_serial}")

            t_subcmd_opts+=('--token-code')
            t_subcmd_opts+=("${t_mfa_token_code}")
        fi

        # We grap the raw JSON output whole; that will be the content of
        # our new cache file.
        #
        local t_raw_json_rsp
        t_raw_json_rsp=$("${__T_V_AWS_AS_AWS_PROG}" "${t_global_opts[@]}" \
                                                sts "${t_srvice_opts[@]}" \
                                  get-session-token "${t_subcmd_opts[@]}")

#        read -r t_access_key_id     \
#                t_secret_access_key \
#                t_session_token     \
#                t_expiration_utc <  \
#          <("${__T_V_AWS_AS_AWS_PROG}" "${t_global_opts[@]}" \
#                                   sts "${t_srvice_opts[@]}" \
#                     get-session-token "${t_subcmd_opts[@]}")
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to get session token for profile: %s\n" \
            "${t_profile_name}" 1>&2
            return 1
        fi
        if test -z "${t_raw_json_rsp}"; then
            printf "${__T_V_AWS_AS_PROG} (error): obtained empty JSON output from get-session-token (???) for profile: %s\n" \
            "${t_profile_name}" 1>&2
            return 1
        fi

        # read cached creds and expiration timestamp from raw JSON output
        # (xargs is there to flatten multiple lines down into one)
        read -r t_access_key_id     \
                t_secret_access_key \
                t_session_token     \
                t_expiration_utc <  \
            <("${__T_V_AWS_AS_XARGS_PROG}" < <("${__T_V_AWS_AS_JQ_PROG}" --raw-output \
                '.Credentials | .AccessKeyId, .SecretAccessKey, .SessionToken, .Expiration' \
                <<< "${t_raw_json_rsp}"))
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to parse raw JSON output from get-session-token for profile: %s\n" \
            "${t_profile_name}" 1>&2
            return 1
        fi
        if test -z "${t_access_key_id}"; then
            printf "${__T_V_AWS_AS_PROG} (error): obtained empty user access key from parsed session token creds\n" 1>&2
            return 1
        fi
        if test -z "${t_secret_access_key}"; then
            printf "${__T_V_AWS_AS_PROG} (error): obtained empty user secret access key from parsed session token creds\n" 1>&2
            return 1
        fi
        if test -z "${t_session_token}"; then
            printf "${__T_V_AWS_AS_PROG} (error): obtained empty user session token from parsed session token creds\n" 1>&2
            return 1
        fi
        if test -z "${t_expiration_utc}"; then
            printf "${__T_V_AWS_AS_PROG} (error): obtained empty user expiration timestamp from parsed session token creds\n" 1>&2
            return 1
        fi

        # create a new cache file for these temporary User creds
        #
        > "${t_fpath}"
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to create user creds cache file: %s\n" "${t_fpath}" 1>&2
            return 1
        fi
        "${__T_V_AWS_AS_CHMOD_PROG}" '0600' "${t_fpath}"
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to set perms on newly created user creds cache file: %s\n" "${t_fpath}" 1>&2
            return 1
        fi
        printf '%s\n' "${t_raw_json_rsp}" > "${t_fpath}"
        if test $? -ne 0; then
            printf "${__T_V_AWS_AS_PROG} (error): was unable to write JSON content to newly created user creds cache file: %s\n" "${t_fpath}" 1>&2
            return 1
        fi
    fi

    # place user creds into environment
    #
    AWS_ACCESS_KEY_ID=${t_access_key_id}
    AWS_SECRET_ACCESS_KEY=${t_secret_access_key}
    AWS_SESSION_TOKEN=${t_session_token}

    # (Maybe) create visual indicator in
    #
    __T_V_AWS_AS_PROFILE=${t_profile_name}
    __t_f_aws_as_maybe_update_PS1

    return 0
}
EOF


    "${CAT_PROG}" - <<'EOF'

# Helper for __t_f_aws_as_try_set_profile_as()
# @param: PROFILE (presumed validated)
#
function __t_f_aws_as_try_set_profile_as_for_role () {

    local t_profile_name

    t_profile_name=$1

    local t_mfa_serial=$("${__T_V_AWS_AS_AWS_PROG}" --profile "${t_profile_name}" configure get 'mfa_serial')
    local t_role_sessn=$("${__T_V_AWS_AS_AWS_PROG}" --profile "${t_profile_name}" configure get 'role_session_name')

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): mfa_serial from aws-cli config: '%s'\n" "${t_mfa_serial}" 1>&2
        printf "${__T_V_AWS_AS_PROG} (debug): role_session_name from aws-cli config: '%s'\n" "${t_role_sessn}" 1>&2
    fi

    # If the role session name from the aws-cli config is not set, then we
    # might still be able to locate the cache file. If we need to force an
    # authentication event for it though (assume-role), we are forced to
    # provide a role session name. We could make one up, or even accept
    # one on the 'aws-as' command line, but for our purposes of hopping
    # between sets of cached credentials it is better for the role session
    # name to come from the config file -- that provides the most reuse
    # (because it impacts the name aws-cli uses for the cache file).
    #
    # For now, we'll force the user to set the value in the config file
    # section for the profile.
    #
    # FIXME: In the future, maybe support a '--role-session-name' config
    #        line opt for 'aws-as' for special purpose overriding of our
    #        default behavior.
    #
    if test -z "${t_role_sessn}"; then
        {
            printf "${__T_V_AWS_AS_PROG} (error): profile has no 'role_session_name' configured\n"
            printf "    HINT: aws --profile '%s' configure set 'role_session_name' 'SOME-LABEL'\n" "${t_profile_name}"
        } 1>&2
        return 1
    fi

    # This is how aws-cli does it (kinda). Not part of their public
    # API, so this approach is subject to change on us at any time.
    # Note that the keys are alphabetically sorted; order here matters.
    #
    local t_cachefile_key=$("${__T_V_AWS_AS_PYTHON3_PROG}" -c '
import sys; import json; from hashlib import sha1;
arn = sys.argv[1];
sn  = sys.argv[2];
rsn = sys.argv[3];
if len(rsn) > 0:
    print( sha1( json.JSONEncoder().encode({"RoleArn": arn, "RoleSessionName": rsn, "SerialNumber": sn}).encode("utf-8") ).hexdigest() )
else:
    print( sha1( json.JSONEncoder().encode({"RoleArn": arn, "SerialNumber": sn}).encode("utf-8") ).hexdigest() )
                            ' \
                            "${t_role_arn}"   \
                            "${t_mfa_serial}" \
                            "${t_role_sessn}"
                           )
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to generate cache file key for role\n" 1>&2
        return 1
    fi
    if test -z "${t_cachefile_key}"; then
        printf "${__T_V_AWS_AS_PROG} (error): generated cache file key for role is empty(???)\n" 1>&2
        return 1
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): generated cache file key for role is '%s'\n" "${t_cachefile_key}" 1>&2
    fi

# FIXME: AL.DEBUG working here
    local t_fpath="${HOME}/.aws/cli/cache/${t_cachefile_key}.json"

    if ${__T_V_AWS_AS_DEBUGGING}; then
        printf "${__T_V_AWS_AS_PROG} (debug): cache filepath is '%s'\n" "${t_fpath}" 1>&2
    fi

    if ${__T_V_AWS_AS_DEBUGGING}; then
        if test -e "${t_fpath}"; then
            printf "${__T_V_AWS_AS_PROG} (debug): cache file exists: '%s'\n" "${t_fpath}" 1>&2
        else
            printf "${__T_V_AWS_AS_PROG} (debug): cache file does not (yet) exist: '%s'\n" "${t_fpath}" 1>&2
        fi
    fi

    if test -e "${t_fpath}"; then :; else

        # If the aws-cli cache file was not found for a given Role-base
        # profile, then one of the following may be true:
        #
        #     1. the profile has never been used (maybe because it is
        #        new, or the user has changed its configuration in such
        #        a way that its SHA-1 has has changed)
        #
        #     2. the cache file was deleted (for whatever reason)
        #
        #     3. some future version of the aws-cli program started using
        #        a different approach to producing the SHA-1 hashes, and
        #        this code is no longer in alignment with what it is doing
        #
        #     4. ???
        #
        # We'll force an authentication event for the profile, and then
        # check again.
        #
        # However, if the profile requires MFA authentication, we will
        # handle ourselves the prompting the user for the MFA token code.
        # The reason for this is that aws-cli will behave in a wonky way
        # that is difficult to error check if we omit the '--token-code'
        # option below and rely on it to do the prompting. (See notes
        # below for more details.)

        if test -n "${t_mfa_serial}"; then

            # This profile requires MFA authentication in order to assume
            # the role

# FIXME: We know we're dealing with a profile for a Role, so the MFA-based
#        authentication needs to be done in the context of the IAM User
#        assuming the role. Delegate that to some other piece of code, and
#        then resume here once the sts:GetSessionToken temporary creds are
#        configured in the environment.

            # There is the tiniest of chances that the user (or more likely,
            # some other tool) has just set the MFA token in the aws-cli
            # configuration file(s). The key name used, though, would be
            # non-standard, as there currently (2020-09) is no official
            # support for any specific key for that purpose.
            #
            # XXX: consider adding support for the mfa token code key names
            #      used by other tools seen in the wild, and use the found value
            #      before falling back on prompting the user for it (as we do here).
            #
            if test -t 0; then :; else
                printf "${__T_V_AWS_AS_PROG} (error): need to prompt user for MFA token, but stdin is not a terminal; stopping\n" 1>&2
                return 1
            fi
            # Prompt here is designed to look just like the one emitted by aws-cli:
            #
            #      Enter MFA code for <mfa-serial-number>:
            #
            # We'll wait 90 seconds for the user to enter the value before giving
            # up. That should be enough time that any futzing with the device can be
            # accommodated.
            #
            local t_mfa_token_code
            read -r -s -t 90 -p "Enter MFA code for ${t_mfa_serial}: " t_mfa_token_code
            if test $? -ne 0; then
                # If our read timed-out or was interrupted, we will not retry
                printf '\n'"${__T_V_AWS_AS_PROG} (error): was unable to obtain MFA code for device '%s'; stopping\n" \
                    "${t_mfa_serial}" 1>&2
                return 1
            fi
            printf '\n'  # advance the line, post-prompting

            # XXX: Writing in 2020-09, a valid MFA token is a six-digit code. We are
            #      hard-coding that here to optimize for the current common case, but
            #      we'll need to change this code in the future if the format changes
            #      (e.g., if AWS starts accepting more than six digits).
            #
            if [[ ${t_mfa_token_code} =~ ^[[:digit:]]{6}$ ]]; then :; else
                printf "${__T_V_AWS_AS_PROG} (error): invalid MFA code entered -- must be exactly six digits; stopping\n" 1>&2
                return 1
            fi
        fi

        local -a t_global_opts=()
        local -a t_srvice_opts=()
        local -a t_subcmd_opts=()

        t_global_opts+=('--output')
        t_global_opts+=('json')

        t_global_opts+=('--profile')
        t_global_opts+=("${t_profile_name}")

        t_subcmd_opts+=('--role-arn')
        t_subcmd_opts+=("${t_role_arn}")

        t_subcmd_opts+=('--role-session-name')
        t_subcmd_opts+=("${t_role_sessn}")

        if test -n "${t_mfa_serial}"; then
#            t_subcmd_opts+=('--serial-number')
#            t_subcmd_opts+=("${t_mfa_serial}")

            t_subcmd_opts+=('--token-code')
            t_subcmd_opts+=("${t_mfa_token_code}")
        fi

set -x
        local t_assume_role_json_output=$("${__T_V_AWS_AS_AWS_PROG}" "${t_global_opts[@]}" \
                                                                 sts "${t_srvice_opts[@]}" \
                                                         assume-role "${t_subcmd_opts[@]}")
        local t_estat=$?
set +x
printf "ALJUNK: t_estat: %s\n"  "${t_estat}" 1>&2

       unset t_subcmd_opts
       unset t_srvice_opts
       unset t_global_opts
       # CAREFUL: aws-cli is wonky in that it may have exited with status 0 /and/
       #          emitted an error indicating that MFA authentication failed /and/
       #          actually succeeded in authenticating and updating the cache file.
       if test $t_estat -ne 0; then
           printf "${__T_V_AWS_AS_PROG} (error): was unable to assume role (%s) for profile: %s\n" \
           "${t_role_arn}" \
           "${t_profile_name}" 1>&2
           return 1
       fi
       if test -z "${t_assume_role_json_output}"; then
           printf "${__T_V_AWS_AS_PROG} (error): received empty JSON output from assume role operation (%s) for profile %s\n" \
               "${t_role_arn}" \
               "${t_profile_name}" 1>&2
           return 1
       fi

printf "ALJUNK: JSON output: %s\n"  "${t_assume_role_json_output}" 1>&2

   fi

# FIXME: Confirm here that our t_fpath (cache file) exists, and then use it to populate the relevant AWS_* env vars
}
EOF

    "${CAT_PROG}" - <<'EOF'

# @param: PROFILE
function __t_f_aws_as_try_set_profile_as () {

    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${__T_V_AWS_AS_PROG} (BUG): ${FUNCNAME}() invoked with %d args; %d required\n" \
            $# ${__required_count} 1>&2
        return 1
    fi

    local t_profile_name

    t_profile_name=$1

    if test -z "${t_profile_name}"; then
        printf "${__T_V_AWS_AS_PROG} (error): profile name may not be the empty string\n" 1>&2
        return 1
    fi

    # XXX: Technically, there might be a way to use a blank profile name
    #      in 'aws-cli', but for now we are not allowing it. Please let
    #      reach out if this causes you grief for some reason.
    #
    if [[ "${t_profile_name}" =~ ^[[:space:]]*$ ]]; then
        printf "${__T_V_AWS_AS_PROG} (error): profile name may not be blank\n" 1>&2
        return 1
    fi

    local -a t_all_legit=()
    for t_one_pname in $("${__T_V_AWS_AS_AWS_PROG}" configure list-profiles); do
        t_all_legit+=("${t_one_pname}")
    done
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to obtain list of all legit aws-cli profile names\n" 1>&2
        return 1
    fi

    local t_is_legit=false
    for t_one_pname in "${t_all_legit[@]}"; do
        if test "${t_one_pname}" = "${t_profile_name}"; then
            t_is_legit=true
            break
        fi
    done

    if $t_is_legit; then :; else
        {
            printf "${__T_V_AWS_AS_PROG} (error): \"%s\" is not a recognized aws-cli profile name\n" \
                   "${t_profile_name}"
            printf '    Legit profile names include:\n'
            for t_one_legit in "${t_all_legit[@]}"; do
                printf '        %s\n' "${t_one_legit}"
            done
        } 1>&2
        return 1
    fi

    # Give ourselves a "clean slate", as it were. This also helps avoid
    # unintended interactions between our aws-cli command line params
    # and any AWS_* variables that were set in the environment.
    #
    __t_f_aws_as_clear_out_creds

    # We need to know whether or not we're dealing with a "User profile"
    # or "Role profile" because it dictates our approach for deal with
    # the cached credentials (if any).
    #
    local t_profile_is_for_iam_role=false
    t_role_arn=$("${__T_V_AWS_AS_AWS_PROG}" --profile "${t_profile_name}" configure get 'role_arn')
    #
    # XXX: The 'configure get' subcommand currently does not indicate
    #      via its exit status whether or not the item was found. There
    #      is no way to distinguish an error from "key not present".
    #      Since we have made it this far, though, the 'aws configure'
    #      command is known to be basically working; so we are going to
    #      interpret a non-zero status as meaning "not found".
    #      Check back on this at some point, and see if PR #4890 has
    #      lead to a change from what is described above:
    #
    #          https://github.com/aws/aws-cli/pull/4890
    #
    if test $? -ne 0; then :; else
        if test -n "${t_role_arn}"; then
            t_profile_is_for_iam_role=true
        fi
    fi

    if $t_profile_is_for_iam_role; then
        __t_f_aws_as_try_set_profile_as_for_role "${t_profile_name}"

    else
        __t_f_aws_as_try_set_profile_as_for_user "${t_profile_name}"
    fi
    if test $? -ne 0; then
        # Presumably a more specific error message was already emitted
        printf "${__T_V_AWS_AS_PROG} (error): was unable to switch to profile: %s\n" "${t_profile_name}" 1>&2
        return 1
    fi

    # Finally, establish our new "switched to" profile settings
    #
    __T_V_AWS_AS_PROFILE=${t_profile_name}
    __t_f_aws_as_maybe_update_PS1

    return 0
}
EOF

    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_main () {

    local t_profile_name
    local t_profile_name_provided=false

    while test $# -gt 0; do
        case $1 in
            '--help' | '-h')
                __t_f_aws_as_print_help
                return 0
                ;;

            '--version' | '-V')
                __t_f_aws_as_print_version
                return 0
                ;;

            '--clear-creds' | '-C')
                __t_f_aws_as_clear_out_creds
                return $?
                ;;

            '--export' | '-E')
                __t_f_aws_as_export_cred_vars
                return $?  # may be non-zero
                ;;

            '--unexport' | '-U')
                __t_f_aws_as_unexport_cred_vars
                return $?
                ;;

            '--verbose' | '-v' )
                if ${__T_V_AWS_AS_BE_VERBOSE}; then

                    if ${__T_V_AWS_AS_DEBUGGING}; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if ${__T_V_AWS_AS_TRACING}; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # Enable tracking before setting our app-level
                            # ${__T_V_AWS_AS_TRACING} flag so that setting it
                            # is the first thing that appears in the trace.
                            set -x
                            __T_V_AWS_AS_TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        __T_V_AWS_AS_DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${__T_V_AWS_AS_PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    __T_V_AWS_AS_BE_VERBOSE=true
                fi
                shift
                ;;


            '--')
                shift
                break
                ;;

            *)
                if [[ "$1" =~ ^[-].* ]]; then
                    printf "${__T_V_AWS_AS_PROG} (error): unrecognized option \"%s\"; bailing out\n" "${1}" 1>&2
                    __t_f_aws_as_print_help 1>&2
                    return 1
                fi
                if ${t_profile_name_provided}; then
                    printf "${__T_V_AWS_AS_PROG} (error): too many AWS_CLI_PROFILE parameters provided (\"%s\"); bailing out\n" "${1}" 1>&2
                    __t_f_aws_as_print_help 1>&2
                    return 1
                fi
                t_profile_name=$1
                t_profile_name_provided=true
                shift
                ;;
        esac
    done

    if ${t_profile_name_provided}; then
        if test $# -gt 1; then
            printf "${__T_V_AWS_AS_PROG} (error): have %d unrecognized parameters (%s); bailing out\n" "$#" "$@" 1>&2
            __t_f_aws_as_print_help 1>&2
            return 1
        fi
    else
        if test $# -gt 0; then
            t_profile_name=$1
            t_profile_name_provided=true
            shift
        elif test $# -lt 1; then
            printf "${__T_V_AWS_AS_PROG} (error): AWS_CLI_PROFILE parameter missing; bailing out\n" 1>&2
            __t_f_aws_as_print_help 1>&2
            return 1
        fi

        if test $# -gt 1; then
            printf "${__T_V_AWS_AS_PROG} (error): have %d unrecognized parameters (%s); bailing out\n" "$#" "$@" 1>&2
            __t_f_aws_as_print_help 1>&2
            return 1
        fi
    fi

    __t_f_aws_as_try_set_profile_as "${t_profile_name}"
    if test $? -ne 0; then
#        printf "${__T_V_AWS_AS_PROG} (error): error encountered why trying to switch to profile: \"%s\"; bailing out\n" "${t_profile_name}" 1>&2
        return 1
    fi

    return 0
}

function aws-as () {
    local t_rstat
    local t_xtrace_was_enabled=false
    case $- in
        *x*)
            t_xtrace_was_enabled=true
            ;;
        *)  # ignore
            ;;
    esac
    __t_f_aws_as_main "$@"
    t_rstat=$?

    __t_f_aws_as_reset_dashv_flags

    # If tracing was enabled during our run, we need to disable it again
    # (unless it had already been enabled to begin with)
    if [[ $- =~ .*x.* ]]; then
        if $t_xtrace_was_enabled; then
            : ${__T_V_AWS_AS_PROG} \(trace: $LINENO\): xtrace had previously been enabled -- no need to disable it
        else
            set +x
        fi
    fi

    return $t_rstat
}
EOF

    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_cleanup () {

    # Ignore any errors from the cleanup statements (what could we do
    # about them, anyway?), and keep going. It is better to potentially
    # leave one unintended artifact in the environment than "all the rest".

EOF
    let t_idx=${#t_cleanup_statements[@]}-1

    # Note that we're running the cleanup statements in opposite order from
    # which they were registered.
    #
    while test ${t_idx} -ge 0; do

        t_one_statement="${t_cleanup_statements[${t_idx}]}"

        if test -n "${t_one_statement}"; then
            "$CAT_PROG" - <<EOF  # Note: unlike the above, /these/ heredoc statements get interpolated
    ${t_one_statement}
EOF
        fi
        let t_idx=${t_idx}-1
    done
    "$CAT_PROG" - <<'EOF'

    # The very last statements in our cleanup function are the deletion
    # of the user-facing 'aws-as-deactivate' "command" (defined below)
    # and our cleanup function itself.
    #
    unset -f aws-as-deactivate
    unset -f __t_f_aws_as_cleanup
}

function aws-as-deactivate () {
    __t_f_aws_as_cleanup
}
EOF

fi


if $BE_VERBOSE; then
    printf "${PROG} (info): completed successfully\n" 1>&2
fi

exit 0;


#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball or RPM, for instance),
# you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='aws-as' \
#               --release='aws-as-0.1.0' \
#               --section='1' \
#               > /outputdir/aws-as-activate.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#
#     'man -l -'
#
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  aws-as-activate - Generate aws-as command (and related) on stdout


=head1 SYNOPSIS

  aws-as-activate --help
  aws-as-activate --version

  eval "$(aws-as-activate -s)"
  eval "$(aws-as-activate -c)"


=head1 DESCRIPTION

The C<aws-as-activate> program is part of the C<aws-as> project.

The C<aws-as-activate> program emits a handful of shell function definitions
and related metadata variables on stdout. These shell constructs provide the
L<aws-as(1)> command (really a shell function) for the current shell. The user
must C<eval> the output in order for the functionality to take effect in the
current shell. The output must be quoted in order to be fed to C<eval> as a
single chunk and to otherwise avoid the shell emitting a syntax error.

Once "installed" in the user's shell, all traces of the funcationality can be
removed by the installed L<aws-as-deactivate(1)> function.

The user's C<$PS1> shell prompt variable will be augmented to indicate the
currently active AWS profile. The original value for the varialbe is
"remembered", and restored to its pristine state upon invoking the
C<aws-as-deactivate> function.


=head1 OPTIONS

Below are the command line options currently accepted by C<aws-as-activate>.


=over 4

=item -h, --help

Print help usage message


=item -V, --version

Print the version of the program to stdout and then exit.


=item -c, --csh

B<WIP: This feature is not currently implemented>

Generate C-shell commands on stdout. This is the default if C<SHELL> looks
like it is a csh style of shell.

This option is mutually exclusive with C<-s> (C<--sh>); only one or the other
may be provided.


=item -s, --sh

B<WIP: This feature is not currently implemented>

Generate Bourne shell commands on stdout. This is the default if C<SHELL> does
not look like it is a csh style of shell.

This option is mutually exclusive with C<-c> (C<--csh>); only one or the other
may be provided.

B<CAREFUL:> This eary WIP version uses "bashisms"; pure POSIX shell support is planned


=item -v, --verbose

Turn on verbose mode. Causes program to emit messages on C<stderr> indicating
what it is doing. The option may be specified multiple times to increase
further the level of verbosity. One C<-v> option enables info-level output;
two such opts enable debug-level output; three or more enable trace-level
output.


=item --

Signals the end of options and disables further options processing.

=back


=head1 DIAGNOSTICS

Exits with zero on success, non-zero on error.


=head1 BUGS

There are probably tons. If you find any, please report them as described in
the C<BUGS> file.

HINT: L<https://github.com/salewski/aws-as/issues>


=head1 SEE ALSO

=over 4

=item aws-as(1)

=item aws-as-deactivate(1)

=back


=head1 AUTHOR

=over 4

=item Alan D. Salewski  <salewski@att.net>

=back


=head1 COPYRIGHT

Copyright 2020 Alan D. Salewski

=cut

