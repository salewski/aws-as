#!/bin/bash -
# SPDX-FileCopyrightText: <text> Â© 2020 Alan D. Salewski <salewski@att.net> </text>
#
# SPDX-License-Identifier: GPL-2.0-or-later

# aws-as-activate.in: Emits a handful of shell functions and metadata
# variables that provide the 'aws-as' command (really a shell function) for
# the current shell. The user must 'eval' the output in order for the
# functionality to take effect in the current shell.
#
# Will augment the user's $PS1 shell variable to indicate the currently active
# AWS profile. The user's original PS1 variable definition is "remembered",
# and restored to its pristine state upon 'aws-as-deactivate' (see below).
#
# Usage:
#
#     $ eval "$(aws-as-activate -s)"
#
# CAREFUL: The double-quotes around the command are important in order to
#          avoid the shell emitting a syntax error.
#
#
# Once "installed" in the user's shell, all traces of the funcationality can
# be removed by the installed 'aws-as-deactivate' function.

declare -r PROG='aws-as-activate.in'

declare -r COPYRIGHT_DATES='2020'

# declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'
declare -r MAINTAINER='@PACKAGE_BUGREPORT@'  # value filtered in at build time

declare -r VERSION='@VERSION@'  # value filtered in at build time

declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
#declare -r gl_const_release="${VERSION}"

# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

CAT_PROG="${CAT:-@CAT@}"

AWS_PROG="${AWS:-@AWS_PROG@}"


opt_target_csh=false  # enable with -c  (or by a $SHELL that looks like a csh style shell)
opt_target_sh=false   # enable with -s  (or by a $SHELL that does not look like a csh style shell)


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $BE_VERBOSE; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

    cat <<EOF
usage: $PROG { -h | --help }
  or:  $PROG { -V | --version }
  or:  $PROG [OPTION...] { -c | --csh }
  or:  $PROG [OPTION...] { -s | --sh }

Generate aws-as command (and related) on stdout

WIP: Options with an asterisk (*) are placeholders for features not yet implemented

  -h, --help                     Print this help message on stdout
  -V, --version                  Print the version of the program on stdout
* -c, --csh                      Generate C-shell commands on stdout. This is the default if
                                   SHELL looks like it's a csh style of shell.
  -s, --sh                       Generate Bourne shell commands on stdout. This is the default if
                                   SHELL does not look like it's a csh style of shell.
  -v, --verbose                  Tell what is being done. Two or more -v options turns on tracing (set -x)
      --                         Signals the end of options and disables further options processing. Any
                                   remaining arguments will cause an error to be emitted.

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['csh']=0       # -c
    ['sh']=0        # -s

    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hVcsv' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Note that we need to restore the leading '-' chars
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '--%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'csh' | 'c' )
                if $opt_target_sh; then
                    printf "${PROG} (error): opt -c (--csh) is mutually exclusive with -s (--sh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_csh=true

#FIXME: implement -c (--csh)
                printf "${PROG} (WIP): -c (--csh) feature not yet implemented; bailing out\n" 1>&2
                f_print_help 1>&2
                exit 1
                ;;


            'sh' | 's' )
                if $opt_target_csh; then
                    printf "${PROG} (error): opt -s (--sh) is mutually exclusive with -c (--csh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_sh=true

#FIXME: implement -s (--sh)
                # printf "${PROG} (WIP): -s (--sh) feature not yet implemented; bailing out\n" 1>&2
                # f_print_help 1>&2
                # exit 1
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level messages). Two -v
                # opts turns on $DEBUGGING, which additionally enables debug-level
                # messages. Three or more '-v' opts turns $TRACING on. Note that
                # if you intend to turn tracing on, you'll probably want your -v
                # opts to be the first opts on the command line (so they take
                # effect earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in 'xtrace'
                            # (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first thing
                            # that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;



            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; note that we need to restore the leading '-' that
                  # getopts has sliced off.
                  printf "${PROG} (error): unrecognized option '-%s'; bailing out\n" "${OPTARG}" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;

        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# FIXME: Decide what to do with any remaining command line parameters not processed by getopts
if test $# -gt 0; then
    printf "${PROG} (error): unrecognized command line parameters (noted below); bailing out\n    %s\n" "$*" 1>&2
    exit 1
fi


if $opt_target_sh \
|| $opt_target_csh; then :; else

    # User did not specify either -s or -c option. We'll try to auto-detect
    # the user's shell from the $SHELL environment variable. If it looks like
    # a csh-style shell, then that's what we'll use. Otherwise we'll assume a
    # Bourne-style shell.
    #
    # Note: This approach of checking the last three characters of the name is
    #       borrowed from the ssh-agent(1), as shipped with OpenBSD's OpenSSH.
    #
    if test "${#SHELL}" -gt 2; then
        if [[ "${SHELL}" =~ .*csh$ ]]; then
            opt_target_csh=true
        fi
    fi
fi


if $opt_target_csh; then
    # csh-style shell

    printf "${PROG} (WIP): csh support not yet implemented; bailing out\n" 1>&2
    exit 1

    # FIXME: implement support for csh
else
    # Bourne-style shell

    # FIXME: For our initial version, we are assuming we can use bashisms

    # We'll populate this list of cleanup statements as we build up the
    # program, and then define a cleanup function with a static list of them
    # at the end of the generated program.
    #
    # Rationale: In the name of security, we want to avoid using 'eval' in the
    # cleanup function installed into the user's current shell environment. We
    # could define our variables as read-only, but then we would be forcing
    # the user to jump in and out of subshell when switch AWS profiles. OTOH,
    # if we use an in-process array of cleanup statements and do not make it
    # read-only, then there is no way to prevent malicious futzing with it
    # before we 'eval' the statements it contains.
    #
    # Instead, we can handle the registration of the static cleanup statements
    # here in the generating program, and then install a function with a
    # static definition of each of the cleanup statements in reverse
    # order. This is safer than using 'eval', and only slightly less
    # convenient here. We do still still get to keep most of the convenience
    # of registering the statements individually where the relevant code is
    # introduced.
    #
    # HINT: To create "spacer lines" in the generated cleanup function (to
    #       help keep the function readable, and also keep groups of related
    #       statements grouped together), use the ':' command.
    #
    declare -a t_cleanup_statements=()

    "${CAT_PROG}" - <<'EOF'
__t_v_aws_as_PS1_hold=
__t_v_aws_as_have_PS1_hold=false
if test "${PS1:+is_set}" = 'is_set'; then
    __t_v_aws_as_PS1_hold=$PS1
    __t_v_aws_as_have_PS1_hold=true
fi
EOF
    t_cleanup_statements+=('unset -v __t_v_aws_as_PS1_hold')
    t_cleanup_statements+=('unset -v __t_v_aws_as_have_PS1_hold')
    t_cleanup_statements+=('${__t_v_aws_as_have_PS1_hold} && PS1=${__t_v_aws_as_PS1_hold}')

    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_AWS_PROG')

    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__T_V_AWS_AS_AWS_PROG=${AWS_PROG}
EOF

    # switch back to using non-interpolated heredoc
    #
    t_cleanup_statements+=(':')

    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROFILE')
    t_cleanup_statements+=('unset -f __t_f_aws_as_maybe_update_PS1')
    "${CAT_PROG}" - <<'EOF'

__T_V_AWS_AS_PROFILE='-'
function __t_f_aws_as_maybe_update_PS1 () {
    if test "${PS1:+is_set}" = 'is_set'; then
        PS1='('"${__T_V_AWS_AS_PROFILE}"') '"${__t_v_aws_as_PS1_hold}"
    fi
}
__t_f_aws_as_maybe_update_PS1

# FIXME: In some scenarios, we might be able to use the "as is" active
#        profile (as indicated by the AWS_PROFILE env var). For now,
#        though, our basic implementation just clears out any AWS_*
#        env vars found in the environment that would conflict with our
#        usage. We are careful to keep track of them, though, and restore
#        the "as found" value to what they were originally when the user
#        invokes 'aws-as-deactivate'.
EOF

    for vname in \
        'AWS_PROFILE' \
        'AWS_ACCESS_KEY_ID' \
        'AWS_SECRET_ACCESS_KEY' \
        'AWS_SESSION_TOKEN'; do

        "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__t_v_aws_as_${vname}_hold=
__t_v_aws_as_have_${vname}_hold=false
if test "\${${vname}:+is_set}" = 'is_set'; then
    __t_v_aws_as_${vname}_hold=\$${vname}
    __t_v_aws_as_have_${vname}_hold=true
    unset ${vname}
fi
EOF
        t_cleanup_statements+=(':')
        t_cleanup_statements+=('unset -v __t_v_aws_as_'"${vname}"'_hold')
        t_cleanup_statements+=('unset -v __t_v_aws_as_have_'"${vname}"'_hold')
        t_cleanup_statements+=('${__t_v_aws_as_have_'"${vname}"'_hold} && '"${vname}"'=${__t_v_aws_as_'"${vname}"'_hold}')
    done


    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -f aws-as')
    t_cleanup_statements+=(':')
    t_cleanup_statements+=('unset -v __T_V_AWS_AS_PROG')
    t_cleanup_statements+=('unset -f __t_f_aws_as_print_help')
    t_cleanup_statements+=('unset -f __t_f_aws_as_print_version')
    t_cleanup_statements+=('unset -f __t_f_aws_as_clear_out_profile')
    t_cleanup_statements+=('unset -f __t_f_aws_as_try_set_profile_as')

    # Design note: To the extent possible, the user-facing 'aws-as' function
    # should feel like a normal command to the end-user.
    #
    "${CAT_PROG}" - <<EOF  # interpolating heredoc statements (okay)

__T_V_AWS_AS_PROG='aws-as'

__t_f_aws_as_print_help () {

    cat <<EODEF
usage: \$__T_V_AWS_AS_PROG { -h | --help }
  or:  \$__T_V_AWS_AS_PROG { -V | --version }
  or:  \$__T_V_AWS_AS_PROG [OPTION...] AWS_CLI_PROFILE

Switch to specified profile, authenticating with MFA, if necessary.

  -h, --help     Print this help message on stdout
  -V, --version  Print the version of the program on stdout

Report bugs to $MAINTAINER.
EODEF
}

__t_f_aws_as_print_version () {
    cat <<EODEF
\${__T_V_AWS_AS_PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EODEF
}
EOF

    # switch back to using non-interpolated heredoc
    #
    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_clear_out_profile () {

    unset AWS_PROFILE
    unset AWS_ACCESS_KEY_ID
    unset AWS_SECRET_ACCESS_KEY
    unset AWS_SESSION_TOKEN

    __T_V_AWS_AS_PROFILE='-'
    __t_f_aws_as_maybe_update_PS1
}

# @param: PROFILE
function __t_f_aws_as_try_set_profile_as () {

    local __required_count=1
    if test $# -ne ${__required_count}; then
        printf "${__T_V_AWS_AS_PROG} (BUG): ${FUNCNAME}() invoked with %d args; %d required\n" \
            $# ${__required_count} 1>&2
        return 1
    fi

    local t_profile_name

    t_profile_name=$1

    if test -z "${t_profile_name}"; then
        printf "${__T_V_AWS_AS_PROG} (error): profile name may not be the empty string\n" 1>&2
        return 1
    fi

    # XXX: Technically, there might be a way to use a blank profile name
    #      in 'aws-cli', but for now we are not allowing it. Please let
    #      reach out if this causes you grief for some reason.
    #
    if [[ "${t_profile_name}" =~ ^[[:space:]]*$ ]]; then
        printf "${__T_V_AWS_AS_PROG} (error): profile name may not be blank\n" 1>&2
        return 1
    fi

    local -a t_all_legit=()
    for t_one_pname in $("${__T_V_AWS_AS_AWS_PROG}" configure list-profiles); do
        t_all_legit+=("${t_one_pname}")
    done
    if test $? -ne 0; then
        printf "${__T_V_AWS_AS_PROG} (error): was unable to obtain list of all legit aws-cli profile names\n" 1>&2
        return 1
    fi

    local t_is_legit=false
    for t_one_pname in "${t_all_legit[@]}"; do
        if test "${t_one_pname}" = "${t_profile_name}"; then
            t_is_legit=true
            break
        fi
    done

    if $t_is_legit; then :; else
        {
            printf "${__T_V_AWS_AS_PROG} (error): \"%s\" is not a recognized aws-cli profile name\n" \
                   "${t_profile_name}"
            printf '    Legit profile names include:\n'
            for t_one_legit in "${t_all_legit[@]}"; do
                printf '        %s\n' "${t_one_legit}"
            done
        } 1>&2
        return 1
    fi

# FIXME: AL.DEBUG working here

    # Give ourselves a "clean slate", as it were...
    #
    __t_f_aws_as_clear_out_profile

    # ...and then establish these profile settings
    #
    __T_V_AWS_AS_PROFILE=${t_profile_name}
    __t_f_aws_as_maybe_update_PS1

    return 0
}

function aws-as () {

    if test $# -lt 1; then
        printf "${__T_V_AWS_AS_PROG} (error): AWS_CLI_PROFILE parameter missing; bailing out\n" 1>&2
        __t_f_aws_as_print_help 1>&2
        return 1
    fi
    if test $# -gt 1; then
        printf "${__T_V_AWS_AS_PROG} (error): too many parameters (expected one, but got %d); bailing out\n" "$#" 1>&2
        __t_f_aws_as_print_help 1>&2
        return 1
    fi

    local t_profile_name

    case $1 in
        '--help' | '-h')
            __t_f_aws_as_print_help
            return 0
            ;;

        '--version' | '-V')
            __t_f_aws_as_print_version
            return 0
            ;;

        *)
            t_profile_name=$1
            ;;
    esac

    if test "${t_profile_name}" = '-'; then
        __t_f_aws_as_clear_out_profile
        return 0
    fi

    __t_f_aws_as_try_set_profile_as "${t_profile_name}"
    if test $? -ne 0; then
#        printf "${__T_V_AWS_AS_PROG} (error): error encountered why trying to switch to profile: \"%s\"; bailing out\n" "${t_profile_name}" 1>&2
        return 1
    fi

    return 0
}
EOF

    "${CAT_PROG}" - <<'EOF'

function __t_f_aws_as_cleanup () {

    # Ignore any errors from the cleanup statements (what could we do
    # about them, anyway?), and keep going. It is better to potentially
    # leave one unintended artifact in the environment than "all the rest".

EOF
    let t_idx=${#t_cleanup_statements[@]}-1

    # Note that we're running the cleanup statements in opposite order from
    # which they were registered.
    #
    while test ${t_idx} -ge 0; do

        t_one_statement="${t_cleanup_statements[${t_idx}]}"

        if test -n "${t_one_statement}"; then
            "$CAT_PROG" - <<EOF  # Note: unlike the above, /these/ heredoc statements get interpolated
    ${t_one_statement}
EOF
        fi
        let t_idx=${t_idx}-1
    done
    "$CAT_PROG" - <<'EOF'

    # The very last statements in our cleanup function are the deletion
    # of the user-facing 'aws-as-deactivate' "command" (defined below)
    # and our cleanup function itself.
    #
    unset -f aws-as-deactivate
    unset -f __t_f_aws_as_cleanup
}

function aws-as-deactivate () {
    __t_f_aws_as_cleanup
}
EOF


fi


if $BE_VERBOSE; then
    printf "${PROG} (info): completed successfully\n" 1>&2
fi

exit 0;


#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball or RPM, for instance),
# you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='aws-as' \
#               --release='aws-as-0.1.0' \
#               --section='1' \
#               > /outputdir/aws-as-activate.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#
#     'man -l -'
#
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  aws-as-activate - Generate aws-as command (and related) on stdout


=head1 SYNOPSIS

  aws-as-activate --help
  aws-as-activate --version

  eval "$(aws-as-activate -s)"
  eval "$(aws-as-activate -c)"


=head1 DESCRIPTION

The C<aws-as-activate> program is part of the C<aws-as> project.

The C<aws-as-activate> program emits a handful of shell function definitions
and related metadata variables on stdout. These shell constructs provide the
L<aws-as(1)> command (really a shell function) for the current shell. The user
must C<eval> the output in order for the functionality to take effect in the
current shell. The output must be quoted in order to be fed to C<eval> as a
single chunk and to otherwise avoid the shell emitting a syntax error.

Once "installed" in the user's shell, all traces of the funcationality can be
removed by the installed L<aws-as-deactivate(1)> function.

The user's C<$PS1> shell prompt variable will be augmented to indicate the
currently active AWS profile. The original value for the varialbe is
"remembered", and restored to its pristine state upon invoking the
C<aws-as-deactivate> function.


=head1 OPTIONS

Below are the command line options currently accepted by C<aws-as-activate>.


=over 4

=item -h, --help

Print help usage message


=item -V, --version

Print the version of the program to stdout and then exit.


=item -c, --csh

B<WIP: This feature is not currently implemented>

Generate C-shell commands on stdout. This is the default if C<SHELL> looks
like it is a csh style of shell.

This option is mutually exclusive with C<-s> (C<--sh>); only one or the other
may be provided.


=item -s, --sh

B<WIP: This feature is not currently implemented>

Generate Bourne shell commands on stdout. This is the default if C<SHELL> does
not look like it is a csh style of shell.

This option is mutually exclusive with C<-c> (C<--csh>); only one or the other
may be provided.

B<CAREFUL:> This eary WIP version uses "bashisms"; pure POSIX shell support is planned


=item -v, --verbose

Turn on verbose mode. Causes program to emit messages on C<stderr> indicating
what it is doing. The option may be specified multiple times to increase
further the level of verbosity. One C<-v> option enables info-level output;
two such opts enable debug-level output; three or more enable trace-level
output.


=item --

Signals the end of options and disables further options processing.

=back


=head1 DIAGNOSTICS

Exits with zero on success, non-zero on error.


=head1 BUGS

There are probably tons. If you find any, please report them as described in
the C<BUGS> file.

HINT: L<https://github.com/salewski/aws-as/issues>


=head1 SEE ALSO

=over 4

=item aws-as(1)

=item aws-as-deactivate(1)

=back


=head1 AUTHOR

=over 4

=item Alan D. Salewski  <salewski@att.net>

=back


=head1 COPYRIGHT

Copyright 2020 Alan D. Salewski

=cut

