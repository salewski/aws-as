#!/bin/bash -
# SPDX-FileCopyrightText: <text> Â© 2020 Alan D. Salewski <salewski@att.net> </text>
#
# SPDX-License-Identifier: GPL-2.0-or-later

# aws-as-activate.in: Emits a handful of shell functions and metadata
# variables that provide the 'aws-as' command (really a shell function) for
# the current shell. The user must 'eval' the output in order for the
# functionality to take effect in the current shell.
#
# Will augment the user's $PS1 shell variable to indicate the currently active
# AWS profile. The user's original PS1 variable definition is "remembered",
# and restored to its pristine state upon 'aws-as-deactivate' (see below).
#
# Usage:
#
#     $ eval $(aws-as-activate -s)
#
#
# Once "installed" in the user's shell, all traces of the funcationality can
# be removed by the installed 'aws-as-deactivate' function.

declare -r PROG='aws-as-activate.in'

declare -r COPYRIGHT_DATES='2020'

# declare -r MAINTAINER='@DFLT_MAINTAINER_FULL@'
declare -r MAINTAINER='@PACKAGE_BUGREPORT@'  # value filtered in at build time

declare -r VERSION='@VERSION@'  # value filtered in at build time

declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${VERSION}  (built: ${gl_const_build_date})"
#declare -r gl_const_release="${VERSION}"

# Note that we use an "application" $TRACING flag separate from bash's
# built-in 'xtrace' (set -x) shell option. This allows us to have a general
# notion of user-requested verbosity separate from any selectively placed
# 'set -x/set +x' sections we may plug into the code while working on the
# program itself; similarly for places where we might want to avoid trace
# output while debugging by selectively placing 'set +x/set -x' sections; both
# of those behaviors would be much more cumbersome to achieve if we just
# checked for 'x' in $- at runtime.
#
BE_VERBOSE=false   # enable with one '-v' (--verbose) opt
DEBUGGING=false    # enable with two '-v' (--verbose) opts
TRACING=false      # enable with three or more '-v' (--verbose) opts


# By default we'll use the external programs found at configure-time (values
# are filtered-in here at build time). But we allow the user to override any
# particular tool by setting an environment variable named after the tool
# (with hyphen chars changed to underscores).

CAT_PROG="${CAT:-@CAT_PROG@}"


opt_target_csh=false  # enable with -c  (or by a $SHELL that looks like a csh style shell)
opt_target_sh=false   # enable with -s  (or by a $SHELL that does not look like a csh style shell)


declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $BE_VERBOSE; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


f_print_help () {

    cat <<EOF
usage: $PROG { -h | --help }
  or:  $PROG { -V | --version }
  or:  $PROG [OPTION...] { -c | --csh }
  or:  $PROG [OPTION...] { -s | --sh }

Generate aws-as command (and related) on stdout

WIP: Options with an asterisk (*) are placeholders for features not yet implemented

  -h, --help                     Print this help message on stdout
  -V, --version                  Print the version of the program on stdout
* -c, --csh                      Generate C-shell commands on stdout. This is the default if
                                   SHELL looks like it's a csh style of shell.
  -s, --sh                       Generate Bourne shell commands on stdout. This is the default if
                                   SHELL does not look like it's a csh style of shell.
  -v, --verbose                  Tell what is being done. Two or more -v options turns on tracing (set -x)
      --                         Signals the end of options and disables further options processing. Any
                                   remaining arguments will cause an error to be emitted.

Report bugs to $MAINTAINER.
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['csh']=0       # -c
    ['sh']=0        # -s

    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hVcsv' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    # Note that we need to restore the leading '-' chars
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '--%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else
                    printf "${PROG} (error): unrecognized long option '--%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'csh' | 'c' )
                if $opt_target_sh; then
                    printf "${PROG} (error): opt -c (--csh) is mutually exclusive with -s (--sh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_csh=true

#FIXME: implement -c (--csh)
                printf "${PROG} (WIP): -c (--csh) feature not yet implemented; bailing out\n" 1>&2
                f_print_help 1>&2
                exit 1
                ;;


            'sh' | 's' )
                if $opt_target_csh; then
                    printf "${PROG} (error): opt -s (--sh) is mutually exclusive with -c (--csh); bailing out\n" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi
                opt_target_sh=true

#FIXME: implement -s (--sh)
                # printf "${PROG} (WIP): -s (--sh) feature not yet implemented; bailing out\n" 1>&2
                # f_print_help 1>&2
                # exit 1
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns
                # BE_VERBOSE on (enables (additional) info-level messages). Two -v
                # opts turns on $DEBUGGING, which additionally enables debug-level
                # messages. Three or more '-v' opts turns $TRACING on. Note that
                # if you intend to turn tracing on, you'll probably want your -v
                # opts to be the first opts on the command line (so they take
                # effect earlier).
                if $BE_VERBOSE; then

                    if $DEBUGGING; then

                        # We've seen at least two -v opt before, so now we're
                        # turning tracing on.

                        if $TRACING; then
                            : $PROG \(trace: $LINENO\): tracing already enabled
                        else
                            # See comments at the decl spot for $TRACING
                            # pertaining to why we maintain an "application"
                            # $TRACING flag separate from bash's built-in 'xtrace'
                            # (set -x) shell option.

                            # Enable tracking before setting our app-level
                            # $TRACING flag so that setting it is the first thing
                            # that appears in the trace.
                            set -x
                            TRACING=true
                        fi
                    else
                        # Second -v opt we're seeing
                        DEBUGGING=true
                        # Just to give a warm and fuzzy...
                        printf "${PROG} (debug): debug-level output enabled\n" 1>&2
                    fi
                else
                    # First -v opt we're seeing
                    BE_VERBOSE=true
                fi
                ;;



            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; note that we need to restore the leading '-' that
                  # getopts has sliced off.
                  printf "${PROG} (error): unrecognized option '-%s'; bailing out\n" "${OPTARG}" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  exit 1
                  ;;

        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# FIXME: Decide what to do with any remaining command line parameters not processed by getopts
if test $# -gt 0; then
    printf "${PROG} (error): unrecognized command line parameters (noted below); bailing out\n    %s\n" "$*" 1>&2
    exit 1
fi


if $opt_target_sh \
|| $opt_target_csh; then :; else

    # User did not specify either -s or -c option. We'll try to auto-detect
    # the user's shell from the $SHELL environment variable. If it looks like
    # a csh-style shell, then that's what we'll use. Otherwise we'll assume a
    # Bourne-style shell.
    #
    # Note: This approach of checking the last three characters of the name is
    #       borrowed from the ssh-agent(1), as shipped with OpenBSD's OpenSSH.
    #
    if test "${#SHELL}" -gt 2; then
        if [[ "${SHELL}" =~ .*csh$ ]]; then
            opt_target_csh=true
        fi
    fi
fi


if $opt_target_csh; then
    # csh-style shell

    printf "${PROG} (WIP): csh support not yet implemented; bailing out\n" 1>&2
    exit 1

    # FIXME: implement support for csh
else
    # Bourne-style shell

    # FIXME: For our initial version, we are assuming we can use bashisms

    ${CAT_PROG} - <<EOF
EOF

fi


if $BE_VERBOSE; then
    printf "${PROG} (info): completed successfully\n" 1>&2
fi

exit 0;


#
# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball or RPM, for instance),
# you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='aws-as' \
#               --release='aws-as-0.1.0' \
#               --section='1' \
#               > /outputdir/aws-as-activate.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#
#     'man -l -'
#
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  aws-as-activate - Generate aws-as command (and related) on stdout


=head1 SYNOPSIS

  aws-as-activate --help
  aws-as-activate --version

  eval $(aws-as-activate -s)
  eval $(aws-as-activate -c)


=head1 DESCRIPTION

The C<aws-as-activate> program is part of the C<aws-as> project.

The C<aws-as-activate> program emits a handful of shell function definitions
and related metadata variables on stdout. These shell constructs provide the
L<aws-as(1)> command (really a shell function) for the current shell. The user
must C<eval> the output in order for the functionality to take effect in the
current shell.

Once "installed" in the user's shell, all traces of the funcationality can be
removed by the installed L<aws-as-deactivate(1)> function.

The user's C<$PS1> shell prompt variable will be augmented to indicate the
currently active AWS profile. The original value for the varialbe is
"remembered", and restored to its pristine state upon invoking the
C<aws-as-deactivate> function.


=head1 OPTIONS

Below are the command line options currently accepted by C<aws-as-activate>.


=over 4

=item -h, --help

Print help usage message


=item -V, --version

Print the version of the program to stdout and then exit.


=item -c, --csh

B<WIP: This feature is not currently implemented>

Generate C-shell commands on stdout. This is the default if C<SHELL> looks
like it is a csh style of shell.

This option is mutually exclusive with C<-s> (C<--sh>); only one or the other
may be provided.


=item -s, --sh

B<WIP: This feature is not currently implemented>

Generate Bourne shell commands on stdout. This is the default if C<SHELL> does
not look like it is a csh style of shell.

This option is mutually exclusive with C<-c> (C<--csh>); only one or the other
may be provided.

B<CAREFUL:> This eary WIP version uses "bashisms"; pure POSIX shell support is planned


=item -v, --verbose

Turn on verbose mode. Causes program to emit messages on C<stderr> indicating
what it is doing. The option may be specified multiple times to increase
further the level of verbosity. One C<-v> option enables info-level output;
two such opts enable debug-level output; three or more enable trace-level
output.


=item --

Signals the end of options and disables further options processing.

=back


=head1 DIAGNOSTICS

Exits with zero on success, non-zero on error.


=head1 BUGS

There are probably tons. If you find any, please report them as described in
the C<BUGS> file.

HINT: L<https://github.com/salewski/aws-as/issues>


=head1 SEE ALSO

=over 4

=item aws-as(1)

=item aws-as-deactivate(1)

=back


=head1 AUTHOR

=over 4

=item Alan D. Salewski  <salewski@att.net>

=back


=head1 COPYRIGHT

Copyright 2020 Alan D. Salewski

=cut

